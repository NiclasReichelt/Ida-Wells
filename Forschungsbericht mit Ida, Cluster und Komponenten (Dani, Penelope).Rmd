---
title: "226305 Forschungsbericht (Beispiel)"
author: "Karla Denzer, Daniel Guib, Penelope Hoeth, Sarah Huß, Lisa Pham, Niclas Reichelt"
date: "Sommersemester 2020"
output:
  word_document:
    toc: yes
    toc_depth: '3'
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 3
    number_sections: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
subtitle: Analyse des Netzwerkes von Ida Barnett Wells - US-amerikanische Journalistin sowie Bürger- und Frauenrechtlerin.
---

__Anleitung__
Dies ist ein Beispiel, wie ein Forschungsbericht aussehen könnte. Bitte verwenden Sie die Vorlagen-Datei für die Struktur. Hier arbeite ich exemplarisch an einem Code-Beispiel die wichtigsten Analyse-Schritte ab. Dies ist nur ein Beispiel und wird für jedes Projekt unterschiedlich ausfallen. Die Projektteams müssen selbst ihren Schwerpunkt setzen. 
Die Forschungsfrage definiert den Aufbau und die Schwerpunktsetzung des Berichts mit. Achten Sie bitte darauf, dass die Datenerhebung und der Datenzugang klar und nachvollziehbar beschrieben wird ebenso wie die Operationalisierung des Codebuchs. 

_Anmerkung 1_: Für dieses Beispiel erstelle ich für die Hauptkapitel das Netzwerk teilweise neu. Das ist nicht zwingend notwendig, stellt aber sicher, dass die Datenbasis immer klar ist. Achten Sie bitte auch darauf, R regelmässig neu zu starten und die eingespielten Werte zu löschen. Am einfachste geht das, wenn Sie unter R > Restart R and run all chunks angeben. Dann können Sie sicher sein, dass nur die aktuellen Werte erfasst werden. 

_Anmerkung 2_: Aufbau des RMarkdown-Dokuments: Bitte übernehmen Sie den Header aus diesem Dokument, das ist der allererste Abschnitt aus dem Dokument mit "title:" etc. komplett. Dann wird Ihr Dokument automatisch richtig mit Inhaltsverzeichnis etc. erstellt. Denken Sie bitte an folgendes:
1. Überschriften setzen mit #, ##, ### (diese werden automatisch im Inhaltsverzeichnis übernommen)
2. Chunks eindeutig benennen, damit diese schneller gefunden werden.
3. Nicht immer ist eine Grafik/Visualisierung sinnvoll und zielführend: nur dann, wenn wirklich wichtig.
4. Kommentierungen im Code immer dann, wenn die Schritte nachvollziehbar gemacht werden: also nicht in jeder Zeile, vor allem wenn der Code quasi reproduziert wird.
5. [Anleitung](https://rmarkdown.rstudio.com/) für gute RMarkdown-Dokumente. Besonders elegant ist es, wenn Sie die berechneten Werte direkt in die Beschreibung übernehmen.
6. Abgabe auf Moodle in einer Zip-Datei als RMarkdown-Dokument, gemeinsam mit den Original-Dateien der Edge- und Nodelist und dem Codebuch sowie dem Link auf das Github-Verzeichnis, in dem alle Daten liegen.

_Anmerkung 3_: Achten Sie auf die Editier-Möglichkeiten der Code-Chunks: nicht immer ist es sinnvoll, sich alle Ergebnisse anzeigen zu lassen: dies lässt sich gut bei den Einstellungen der Chunks steuern, ebenso wie die Abbildungsgröße. 

*** Die Anleitung und die Anmerkungen natürlich löschen vor Abgabe ***

__Abstract und Keywords__
Gegenstand dieser Forschungsarbeit ist Ida B. Wells, ihr Unterstützernetzwerk, ihr Einsatz für Frauenrechte und gegen Rassismus. Dafür wurden 58 Knoten mit 123 Kanten erfasst und in einem Ego-Netzwerk dargestellt, darunter Personen sowie Organisationen. 
Im Netzwerk werden unterschiedliche Arten von Beziehungen zwischen den Knoten beschrieben. Neben Unterstützern stehen auch Freundschaften, Konflikte und Geschäftliche Verhältnisse im Fokus der Analyse. Außerdem wurde Wells Biographie nach Zeitperioden und Orten unterteilt. Die verschiedenen Lebensabschnitte, wie die Reisen nach Großbritannien, waren die Basis für die Unterteilung in Zeitperioden. Im Verlauf der Analyse liegt der Fokus auf der Wirkung, die Reise nach England auf Wells und ihr Netzwerk hatte. Dabei stellte sich heraus, dass sie sich danach vermehrt für Frauenrechte und “Club Activism” einsetzte. Entgegen unserer Annahme, dass ihre Unterstützer:innen vor allem dunkelhäutige Frauen waren, ergab sich, dass es sich auch um weiße Männer handelte.

Keywords: **Suffragetten, Wells, Netzwerkanalyse, Frauenrechte, Rassismus**



# Einleitung
Vor etwa hundert Jahren wurde das Frauenwahlrecht eingeführt. Heute kann man sich kaum mehr vorstellen, dass das einmal so war. In den 1920er Jahren setzten sich die sogenannten Suffragetten für das Wahlrecht von Frauen ein. Allerdings lagen dunkelhäutige Frauen außen vor. Journalistin Ida B. Wells setzte sich für Schwarzen- und Frauenrechte zugleich ein. Damit war sie ihrer Zeit weit voraus und traf auf Widerstand und Ausgrenzung. Ziel des Projektes ist es auszuarbeiten, wie verschiedene Akteure der Suffragetten- und Anti-Rassismus-Bewegung in den USA und Großbritannien zusammen gearbeitet haben. Im besonderen soll Wells und ihre Leistungen/Fortschritt/Erfolg/Errungenschaften für die Bewegung analysiert werden. Wir erhoffen uns von der Netzwerkanalyse, die Zusammenhänge und Dynamiken aus Wells Perspektive nachvollziehen zu können. 
Die aktuelle Black Lives Matter Bewegung und die Diskussion um Frauenrechte und Gleichstellung der Geschlechter haben für uns einen aktuellen Bezug geschaffen. (Das war für uns ein Grund tiefer in das Thema einzutauchen und eine Wissenslücke zu schließen.)


# Vorarbeiten und vergleichbare Studien
## Forschungsstand
Die Suffragetten haben einen erheblichen Eindruck in unserer Historie hinterlassen. Selbst ein Jahrhundert nach der Einführung des Frauenwahlrechts, das große Ziel der früheren Frauenrechtsbewegung, sind ihre Taten noch von Relevanz. Feminismus – ein Thema, das heutzutage stärker als noch nie zuvor Debatte stehen, insbesondere die Position der Frau in der Arbeitswelt. Deshalb war und ist die Suffragetten-Bewegung Gegenstand beträchtlicher Forschungsarbeiten und eine Inspirationsquelle für literarische Werke und Filme. Dabei war nicht nur der Kampf um das Frauenwahlrecht der interessanteste Aspekt. Vielmehr fokussieren sich die bisherigen Forschungen auf die militante Herangehensweise der Bewegung und die Strukturen und Beziehungen zwischen den Mitgliedern und den Unterstützern. Militanz, Gewalt und Protestakte kennzeichneten die Bewegung stark. Dadurch differenzierten sie sich vom traditionellen Bild der Frau, die dem Mann unterlegen und charakterlich schwach sei. Die Suffragetten waren rebellisch und kämpferisch. Eigenschaften, die Frauen sonst nicht zugeschrieben werden. Keine Überraschung also, dass die Pankhurst-Frauen aus Großbritannien, die Anführerinnen der Bewegung, oftmals genauer analysiert wurden. Etliche Porträts, Biografien und Netzwerke wurden rund um Emmeline Pankhurst und ihre Töchter verfasst.
Die Suffragetten-Bewegung in Großbritannien weitete sich auch aufs Ausland aus und nahm besonders großen Einfluss auf die Frauenrechtlerinnen in den USA. Im Vergleich zu der Organisation in Großbritannien wurde die US-amerikanische Bewegung weitaus weniger erforscht. Zum einen könnte das daran liegen, dass die Suffragetten in den USA vergleichsweise friedlich protestiert haben. Andererseits war der Ursprung der Suffragetten-Bewegung in England und andere Frauenrechtlerinnen haben sich die Pankhursts zu Vorbildern genommen. Dementsprechend hat die Forschung im Bereich der Netzwerkanalyse ihren Fokus auf die militanten Suffragetten in Großbritannien. Ein Beispiel von vielen dafür ist zum Beispiel „Qualitative Social Network Analysis: Visualising and Analysing the Personal Networks of Suffragettes“ von SAGE Publications, worin anhand qualitativer Netzwerkanalyse die Beziehungen rund um Emmeline Pankhurst untersucht wird. Obwohl die Pankhursts unmittelbar im Zentrum der Bewegung standen, haben auch andere Suffragetten durch ihre auffallenden Protestaktionen ihre Aufmerksamkeit auf sich gezogen. So wurde in der Forschungsarbeit “Measures and Meanings: Exploring the Ego-Net of Helen Kirkpatrick Watts, Militant Suffragette” von G. Edwards und N. Crossley ein ganzes Egonetzwerk für Helen Kirkpatrick gestaltet.
Kaum behandelt wurde aber das Thema Rassismus innerhalb der Suffragetten-Bewegung. Insbesondere in den USA haben sich weiße Suffragetten-Gruppen gegen schwarze Frauen positioniert. Kampf um das Wahlrecht – nur für die weiße Frau. Äußerst bemerkenswert ist daher der Werdegang von schwarzen Frauen in der Geschichte, die sich unvoreingenommen für alle eingesetzt hat. Die bisherigen Studien haben uns lediglich inspiriert, tiefer in das Thema einzutauchen und schließlich sind wir auf die Autobiographie von Ida B. Wells gestoßen, eine schwarze Suffragette, die sowohl gegen Rassismus und Sexismus eine klare Haltung zeigte. Daher konnten uns die bisherigen Forschungsarbeiten zu den Suffragetten nur wenige Ansatzpunkte geben. Im Folgenden sollen die relevantesten Anknüpfungspunkte aufgegriffen werden, angefangen mit der Suffragetten-Bewegung im Allgemeinen.

# Suffragetten-Bewegung (Lisa)
Über Jahrzehnte hinweg hatten Frauen vergeblich für ihr Wahlrecht gekämpft, in Großbritannien noch engagierter als anderswo in Europa. Die Suffragetten waren organisierte Frauenrechtlerinnen des frühen 20. Jahrhunderts in Großbritannien und später auch in den Vereinigten Staaten, die im In- und Ausland viel Aufsehen erregten. Ihr Ziel war ein allgemeines Frauenwahlrecht zu denselben Konditionen wie die Männer, wofür sie sich vor allem mit militanten Mitteln, Widerstand und Hungerstreiks einsetzten. Daher kam auch der Name; das englische Wort „suffrage“ bedeutet übersetzt „Wahlrecht“. Ursprünglich wurde der Begriff „Suffragetten“ von der englischen Presse als Herabwürdigung der Aktivistinnen genutzt. Die Suffragetten aber nahmen diese Bezeichnung für sich ein. Die Bewegung hat ihren Ursprung in Großbritannien und entwickelte sich aus Gegnerinnen der „Contagious Diseases Acts 1864-69“, ein Gesetz über Zwangsuntersuchungen von Prostituierten zur Verhütung von Geschlechtskrankheiten. Ihr Engagement führte später sogar zur Gesetzesaufhebung. Dieser Erfolg radikalisierte Befürworterinnen eines Frauenwahlrechts.
So gründete Emmeline Pankhurst 1903 mit ihren Töchtern Christabel und Sylvia die „Women’s Social and Political Union“ in Großbritannien. Eine Partei für Frauen, unabhängig welcher Schicht und Altersgruppe sie angehörten, deren Motto lautet: Taten statt Worte. Pankhurst galt als Wegbereiterin und Begründerin der militanten Strömung der britischen Frauenrechtlerinnen. Daher wird generell die Entstehung der Suffragetten-Bewegung mit Pankhursts Partei-Gründung in Verbindung gebracht. Von da an kämpften die Suffragetten mit demonstrativen Protesten wie Aufmärschen, offenen Kundgebungen und landesweiten Kampagnen. Dabei setzten sie bewusst auf Strategien der Propaganda der Sozialisten, um auf ihr politisches Anliegen aufmerksam zu machen. Die Wahlrechtskampagne wurde zwar durch den Ersten Weltkrieg zeitweise unterbrochen. Dennoch erreichte die Bewegung im Laufe der Zeit ihr Ziel: das Wahlrecht für Frauen ab 30 Jahren mit Grundeigentumsbesitz wurde 1918 eingeführt, zehn Jahre später durften schließlich alle Frauen über 21 wählen – zu den gleichen Bedingungen wie die Männer.
Inspiriert von der kämpferischen Energie der Pankhursts gründete Alice Paul im Jahre 1916 gemeinsam mit Lucy Burns in den USA die „National Woman’s Party“ – das Äquivalent zur britischen Frauenrechts-Partei. Die beiden führten mit der Organisation eine Serie von Protesten gegen den damaligen US-Präsidenten Woodrow Wilson an. Genauso wie in Großbritannien kam der Kampf um Frauenrechte aufgrund des Ersten Weltkrieges ins Stocken. Schließlich wurde 1919/20 in den USA das Wahlrecht für Frauen umgesetzt. Diese allgemeine Akzeptanz des Frauenwahlrechts war auch auf den durch den Krieg bedingten Arbeitsmangel zurückzuführen.

# Rassismus innerhalb der Suffragetten-Bewegung
Sarah, Penelope
Bei den Suffragetten war damit das Frauenwahlrecht die zentrale Forderung der Bewegung. Es hieß: Feminismus statt Humanismus, das Frauenrecht an erster Stelle vor den Rechten der anderen und somit vor den Rechten von Farbigen. Die Suffragettenbewegung war geprägt von Rassismus: durch die weiße Exklusivität in den Clubs und vor allem durch raue und rassistische Wortwahl gegenüber farbigen Menschen. Emmeline Pankhurst, eine bekannte Suffragette, behauptete “Lieber Rebellin als Sklavin”. Durch die Industrialisierung und Kolonialisierung lebten Anfang des 20. Jahrhunderts jedoch gerade in den europäischen Großstädten eine Vielzahl von farbigen Menschen. Sie lebten dabei jedoch in Armut und waren Teil der unteren Arbeiterklasse. Da sie Suffragettenbewegung sich hauptsächlich in der bürgerlichen Mittelschicht, mit Verbindungen zum hohen Adel abspielte, beschäftigten sie sich wenig mit der Unterdrückung der schwarzen Gleichgesinnten. Als 1893 allen Frauen in der Kolonie Neuseeland das Wahlrecht zugesprochen wurde, fassten die Britinnen das eher als eine Beleidigung anstatt einen Etappensieg auf. Sie waren Frauen mit einem gewissen Stand in der Gesellschaft und waren vom Wahlrecht ausgeschlossen. 


# Ida B. Wells
Karla (noch nicht vollständig)
Ida B. Wells setzte sich sowohl für die Rechte der Schwarzen ein, als auch für die Rechte der Frauen. Die meisten Suffragetten verwehrten schwarzen Frauen an ihren Protesten teilzunehmen. Deshalb bemühte sie sich um politische Clubs, in denen beide Anliegen vertreten werden konnten und schwarze Frauen erwünscht waren. 
Ida wurde 1862 in Mississippi geboren, als Sklavin. Ihre Eltern starben beide an Gelbfieber und sie musste sich schon früh um ihre jüngeren Geschwister kümmern, auch finanziell. Sie begann als Lehrerin zu arbeiten. Diese Arbeit erfüllte sie aber längst nicht so sehr, wie die Arbeit als Journalistin, die sie recht früh für sich entdeckte. Ida machte auf Missstände aufmerksam und war dabei sehr erfolgreich. Gleichzeitig brachte sie das Schreiben aber auch in Gefahr und machte sich Feinde. Als sie über die Lynchmorde in ihrer Heimatstadt berichtete, wurde ihr mit dem Tod gedroht. “They had me an exile and threatened my life for hinting at the truth. I felt that I owed it to myself and my race to tell the whole truth”, sagte Ida später. Als sie auf einer Zugfahrt das Zugabteil verlassen musste, währte sie sich und gewann später sogar vor Gericht. Sie begann, sich immer mehr politisch einzusetzen und reiste dafür durch die USA und nach Großbritannien. Gerade diese Reise hatte einen großen Einfluss: da sie Aufmerksamkeit für die Lynchmorde schaffte, woraufhin sich auch andere mit großem Engagement und sehr erfolgreich dagegen einsetzten. Außerdem hatte das “Clublife” in Großbritannien dazu inspiriert, selbst noch mehr politische Vereine für schwarze Frauen zu gründen. Zu diesen gehören zum Beispiel der Alpha Suffragette Club oder auch der xxx. Sie hatte eine komplizierte Beziehung zu Frauen wie Susan Anthony, also zu weißen Suffragetten. Bei einem großen Protest in Washington war es den schwarzen Frauen verboten worden, vorne mitzulaufen. Das ließ sich Ida aber nicht gefallen und am nächsten Tag war sie auf dem Titelbild der Zeitung zu sehen, wie sie mit Susan Anthony etc. an der Spitze des Marschs protestierte. 
Ida B. Wells war ihrer Zeit weit voraus und riskierte mehrmals ihr Leben für ihre Ideale. Obwohl sie sehr viele Erfolge verzeichnen konnte, war sie selbst nie mit sich und den Fortschritten zufrieden. Sie war 50 Jahre alt, als einige Frauen endlich das Wahlrecht bekamen, doch schwarze Frauen war davon ausgeschlossen. “The way to right wrong things is to turn the light of truth upon them.”, sagte Ida. Und genau dem hat sie ihr Leben verschrieben. 


## Arbeitshypothesen
Wir gehen von folgenden Arbeitshypothesen aus:
Zu Beginn der Recherche rechneten wir damit, dass Idas Unterstützernetzwerk vor allem aus dunkelhäutigen Frauen bestand. Wir dachten, dass sie, als Betroffene, ein höheres Interesse daran haben würden, als weiße Männer beispielsweise. 
Außerdem gingen wir davon aus, dass sich die Personen in ihrem Umfeld vermehrt für Frauenrechte einsetzten, anstatt für die Rechte von Schwarzen. Das liegt auch daran, dass wir im Kontext der Suffragettenbewegung (Alpha Suffrage Club) das erste Mal von ihr gehört haben. 
Unsere Vermutung war, dass die Journalist*innen in ihrem Umfeld politisch aktiv waren. Gerade, da die meisten für Zeitungen schrieben, die eine gewisse politische Ausrichtungen hatten. 
Der Reise nach Großbritannien rechneten wir einen großen Einfluss zu und gingen davon aus, dass sie sich danach verstärkt für Frauenrechte eingesetzt hat, da die Suffragettenbewegung hier ihre Wurzeln hat.
 
Unterstützer sind vor allem dunkelhäutige Frauen
Mehr Leute haben sich für Frauenrechte eingesetzt, als für die Rechte von Schwarzen (in Idas Umfeld)
fast alle Journalisten sind in Politik/Aktivismus aktiv (in Idas Umfeld)
nach Idas Reise nach England hat sie sich noch mehr für Frauenrechte eingesetzt
-> Muster in Beziehungen zu erkennen?


Die Analyse einen überwiegend explorativen Charakter, um Muster in den Beziehungen untersuchen.

# Datenerhebung: Zugang, Bereinigung und Codebuch

## Datenzugang
Den Großteil unserer Daten haben wir aus Ida Wells Autobiographie "Crusade for Justice" nehmen können. Zusätzliche Netzwerke innerhalb des Suffragettenmovements der USA sind auch in verschiedenen Internetquellen zugänglich gewesen. Wir hatten uns vorgenommen die Beziehungen und Verbindungen von Ida B. Wells durch die Lektüre ihrer Autobiographie „Crusade for Justice“ herauszubekommen. Ihr Werk eignete sich dafür gut, da sie ihre Treffen und Engagements mit anderen Personen recht ausführlich beschrieb. Bereits während der Lektüre notierten wir uns Informationen und Hintergründe zu den Personen, die uns im Hinblick auf Wells‘ Leben relevant genug erschienen. Indizien dafür waren unter anderem die Häufigkeit der Erwähnung oder die Ausführlichkeit der Beschreibung. Der nächste Schritt war dann die Einarbeitung der gewonnenen Informationen in die Node- und Edgelist. Da Ida B. Wells in ihrer Biographie nicht immer alle Daten zu den Personen lieferte, wie z.B. Hautfarbe oder Organisationszugehörigkeit, mussten wir unsere Datenerhebung auf verschiedene Internetquellen erweitern um die fehlenden Informationen einzuholen. Das Ergebnis in der Nodelist waren dann die Personen mit ihren Attributen type (Organisation oder Person), profession (Spezialgebiet), sex (Geschlecht), skincolor (Hautfarbe), power (Macht/Einfluss), affiliation (Zugehörigkeit einer Organisation). Später fügten wir noch das Attribut motivation hinzu, um die politische Motivation zu unterscheiden. In der Edgelist sollte so gut wie jede Person oder Organisation eine Beziehung zu Ida B. Wells haben. Auch Beziehungen zwischen den anderen Personen und Organisationen nahmen wir mit auf in die Liste. Als Attribute eigneten sich unserer Meinung nach hier relation (Art der Beziehung), weight (Stärke der Beziehung), year (Jahr der Begegnung), country (Land der Begegnung), city (Stadt der Begegnung). Da wir die Beziehungen aus ihrer Biographie nicht mit Sicherheit einer bestimmten Jahreszahl zuordnen konnten, unterteilten wir sie in Zeitperioden, chronologisch nach dem Zeitpunkt der Erwähnung in der Biographie.

## Bereinigung des Datensatzes
Der Datensatz ist unter [Github](https://github.com/NiclasReichelt/Ida-Wells) verfügbar.
Fehlermeldungen:

- Nicht alle aus der Edge.Liste sind in der Node-Liste eingetragen -> vertauschen non ID und Name
- Profession (&Relation) hatten wir zwei Werte mit Komma getrennt in der Zelle stehen 
-> Fehlermeldung und wir haben für Profession eine zweite Spalte angelegt 
-> Problem bei der Selektion: für jede Profession muss eine eigene Spalte angelegt werden

-> unterschiedliche Beziehungen werden durch zwei verschiedene Kanten definiert (1,5..)
- Kommas und Rechtschreibfehler ganz genau untersuchen
- Weglassen von n/a hat zu Fehlermeldungen geführt -> wieder in die Liste eingeführt
- Bei dem Datensatz kann keine Vollständigkeit garantiert werden da die Autobiographie von Ida abbricht als sie stirbt und viele Beziehungen nicht mehr fertig definiert oder analysiert werden können
-> auch aufgrund der
- Grobe Einteilung von Zeitperioden von ihrem Leben zur besseren Visualisierung und Analyse der Lebensabschnitte


## Codebuch
Das [Codebuch](https://github.com/NiclasReichelt/Ida-Wells/blob/main/Ida%20Wells%20-%20Ego%20-%20Codebuch.csv) beschreibt die Variablen, Relationen und Gewichte des Netzwerks und ist ebenfalls auf Github hinterlegt.

# Analyse und Interpretation
blablabla

## Das Gesamtnetzwerk

Das Gesamtnetzwerk umfasst 57 Knoten und 93 Beziehungen (siehe igraph-Objekt). Es ist ungerichtet und gewichtet.

```{r Gesamnetzwerk erstellen, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}

library(igraph)

# Einlesen der Edge- und Nodelist
el <- read.csv("https://raw.githubusercontent.com/NiclasReichelt/Ida-Wells/main/Ida%20Wells%20-%20Ego%20-%20Finale%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/NiclasReichelt/Ida-Wells/main/Ida%20Wells%20-%20Ego%20-%20Finale%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")

# Matrix erstellen
edgematrix <-as.matrix(el)

# Zusammenführen von Edge- und Nodelist als igraph-Objekt s
Ida <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
```

```{r Beschreibung des Netzwerks, message=FALSE, warning=FALSE, paged.print=TRUE}
# Parameter zu Beschreibung des Netzwerks

## ist das Netzwerk bereits vereinfacht?
is.simple(Ida)

#Analyse der Komponenten
is_connected(Ida)

## Die Ausgabe der logischen Operators "TRUE" bedeutet, dass es sich nur um eine Komponente handelt.

components(Ida)

##Die Knoten werden der Gruppen der Komponenten zugewiesen. Der Befehl zeigt uns die Größe und die Verteilung der Komponenten an.

count_components(Ida)

##Das Gesamtnetzwerk besteht aus einer einzigen Komponente. Das heißt alle Knoten haben eine Verbindung miteinander. 

#Community Analyse
#Anzahl der Cluster
clusters(Ida)
#Clusterung 
cluster_Ida <- cluster_walktrap(Ida)
cluster_Ida

## Wir wenden die Clusterung mit dem Walktrap-Algorithmus auf unser Netzwerk an.


#berechnet den Modularitätswert
modularity(cluster_Ida) 
#weist die Mitgliedschaft in die Communities zu.
membership(cluster_Ida) 
#visualisiert die Communities
plot(cluster_Ida, Ida, edge.arrow.size=0.1, main="Walktrap Cluster") 

## In der Darstellung werden uns 10 verschiedene Cluster angezeigt, mal kleinere, mal größere. Ein großes Cluster bildet sich durch den Algorithmus um die Journalist:innen rund um Ida. Innerhalb dieses Clusters gibt es mehrere Verbindungen zu anderen kleineren Clustern. Das könnte darauf hinweisen, dass das Netwerk um die Journalist:innen eine Relevanz in Idas Unterstützungsnetzwerk hat. 

# Anzahl der Clusters
clusters(Ida)

# Komponenten auftrennen
Ida_comp <- decompose.graph(Ida)
Ida_comp

# Komponenten neu benennen
Ida_comp1 <- Ida_comp[[1]]


# Berechnung der Cluster innerhalb der Komponente
# erstellt die Berechnung für die Modularität und deren Teilgruppen
Ida_cl <- cluster_walktrap(Ida_comp1)
modularity(Ida_cl)
membership(Ida_cl)

# Clusterberechnung
plot(Ida_comp1,
     edge.arrow.size=.3,
     vertex.color="lightblue",
     vertex.frame.color=NA,
     main="Komponente 1 ")

# Berechnung der Cluster innerhalb der Komponente

# Wir verwenden die oben erstellte Aufteilung der Cluster
membership(Ida_cl)

# mit dem Befehl sizes wird die Größe der jeweiligen Communities angezeigt
sizes(Ida_cl)

# communities() liefert eine Zuordnung der jeweiligen Knoten auf die Communities
communities(Ida_cl)
 

# erstellt die Berechnung für die Modularität und deren Teilgruppen
Ida_eb <- cluster_edge_betweenness(Ida_comp1)
Ida_eb

plot(Ida_eb, Ida_comp1,
     edge.arrow.size=.2,
     main="Edge-Betweenness Cluster")

##Um einen Vergleich von den Clustermethoden zu haben, generieren wir mithilfe von dem Algorithmus der Cluster-Edge-Betweeness eine weitere Darstellung des Netzwerks mit Clustern. Hier bilden sich in der Darstellung viel mehr Cluster als beim Walktrap-Algorithmus. Das liegt daran, dass die Cluster sich an den "Sollbruchstellen" des Netzwerks trennen. Da die meisten Verbindungen mit Ida bestehen und weniger untereinander, entstehen dadurch Cluster um einzelne Knoten. 

# Berechnung Walktrap-Methode
Ida_wt <- cluster_walktrap(Ida_comp1)

# Visualisierung im Vergleich (Walktrap und Edge-Betweeness)

par(mfrow=c(1,2), mar=c(0,0,2,1)) 
plot(Ida_eb, Ida_comp1, edge.arrow.size=.2, main="Walktrap-Cluster")
plot(Ida_wt, Ida_comp1, edge.arrow.size=.2, main="Edge-Between-Cluster")
par(mfrow=c(1,1), mar=c(0,0,2,1)) 

## Im Vergleich eignet sich der Walktrap-Algorithmus für unser Netzwerk deutlich besser als die Edge-Betweenness-Clusterung. 

## Dichte des Netzwerks
edge_density(Ida, loops=FALSE)

## Umfang des Netzwerks
diameter(Ida)

## Pfaddistanzen (Distance)
farthest_vertices(Ida)
```

Das Hauptnetzwerk besteht aus zwei Komponenten mit 32 und 6 Knoten, die nicht miteinander verbunden sind. Die Dichte im Netzwerk beträgt 12,51 Prozent von allen möglichen Verbindungen. Die maximale Pfaddistanz beträgt 18 Schritte.

```{r Einfache Visualisierung des erstellten Objekt, fig.height=10, fig.width=14, message=TRUE, warning=TRUE, paged.print=TRUE}

V(Ida) [V(Ida)$type == 1] $shape <- "circle"
V(Ida) [V(Ida)$type == 2] $shape <- "square"
V(Ida) [V(Ida)$type == 2] $color <- "orange"

V(Ida) [V(Ida)$sex == 2] $shape <- "rectangle"
V(Ida) [V(Ida)$sex == 3] $shape <- "rectangle"


V(Ida) [V(Ida)$type == 1] $frame.color = NA
V(Ida) [V(Ida)$type == 1] $frame.color = NA 

V(Ida) [V(Ida)$skincolor == 1] $color <- "lightblue"
V(Ida) [V(Ida)$skincolor == 2] $color <- "lightgreen"
V(Ida) [V(Ida)$skincolor == 3] $color <- "red"

V(Ida) [V(Ida)$power == 1] $size <- 5
V(Ida) [V(Ida)$power == 2] $size <- 10
V(Ida) [V(Ida)$power == 3] $size <- 15

plot(Ida,
     asp=0, 
     layout=layout_with_kk,
     edge.arrow.size=.5,
     main ="Übersicht Gesamtnetzwerk")
```
### Netzwerke vereinfachen
Der erste Überblick zeigt, dass das Netzwerk schnell unübersichtlich wird, weil hier drei Beziehungsarten mit zum Teil mehreren Gewichten in einer Abbildung dargestellt werden.
Deshalb ist es sinnvoll, ein vereinfachtes Gesamtnetzwerk zu erstellen. Vereinfacht bedeutet, dass die unterschiedlichen Beziehungsarten ignoriert werden und dafür die Gewichte des Hilfs- und Ratsuche Netzwerk zusammengefasst werden (um das Ergebnis nicht zu verfälschen, wird das Beziehungsnetzwerk vorher gelöscht)

```{r Vereinfachtes Gesamtnetzwerk, fig.height=8, fig.width=12, message=FALSE, warning=FALSE}

# Gesamtnetzwerk erstellen
# Der Code wird hier nur eingefügt, falls der Chunk später alleine weiterverwendet wird.


# simplify Gesamtnetzwerk 
```

Die Anzahl der Knoten ist gleich geblieben (38), aber die Anzahl der Kanten hat sich auf 124 reduziert. Die Verteilung des Gewichts lässt klare Präferenzen innerhalb des Netzwerks zwischen einzelnen Dyaden zeigen. Diese Vorselektion ist später wichtig, um starke Beziehungspaare innerhalb des Netzwerks zu analysieren.

```{r Visualisierung vereinfachtes Gesamtnetzwerk, fig.height=10, fig.width=14, message=FALSE, warning=FALSE, paged.print=FALSE}

# In diesem Netzwerk besteht nur noch eine Beziehung von Knoten zu Knoten, der jedoch unterschiedlich stark gewichtet ist. Hier lässt sich aber keine Aussage mehr darüber treffen, ob es sich um das Zusammenarbeits- oder Unterstützungsnetzwerk handelt. 



```

__Nur starke Beziehungen im Gesamtnetzwerk__

Für dieses Netzwerk sollen nun nur noch starke Beziehungen mit einem Gewicht von >= 2 angezeigt werden. Damit wird das Netzwerk in ein neues Teilnetzwerk zerlegt, das nur noch aus starken Beziehungen besteht:

```{r Starke Beziehungen im Gesamtnetzwerk, fig.height=9, fig.width=16, message=FALSE, warning=FALSE, paged.print=TRUE}

# erstellt ein Teilnetzwerk nur aus starken Beziehungen

Ida_strong <- subgraph.edges(Ida, E(Ida)[weight >=2]) 
Ida_strong
edge.attributes(Ida_strong)$weight

plot(Ida_strong,
     asp=0,
     layout=layout_with_kk,
     #vertex.size=3,
     vertex.label.cex=2,
     #edge.arrow.size=2,
     edge.curved=.3,
     edge.curved=curve_multiple(Ida_strong),
     )

title("Gesamtnetzwerk: Starke Beziehungen", 
      sub = "Gewicht kleiner 2",
      cex.main = 2, col.main= "black",
      cex.sub = 2, font.sub = 3, col.sub = "black")

#Analyse der Komponenten
is_connected(Ida_strong)
components(Ida_strong)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_strong)
#Clusterung 
cluster_Ida_strong <- cluster_walktrap(Ida_strong)
cluster_Ida_strong
#Modularitätswert
modularity(cluster_Ida_strong) 
#Mitgliedschaft 
membership(cluster_Ida_strong) 
#visualisiert die Communities
plot(cluster_Ida_strong, Ida_strong, edge.arrow.size=0.1, vertex.color="lightblue", main="Cluster Ida starke Beziehungen") 

## In der Darstellung des Teilnetzwerks mit starken Beziehungen bilden sich 9 verschiedene Cluster. Hier müssen wir nochmal drüberschauen!!!!!!!!!!!!!!!!!



```



```{r Hervorhebung der populärsten Knoten im Netzwerk, fig.height=6, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}
#von Sandhu (brauchen wir das überhaupt) Ida ist ja der populärste 

# mit der Auswahl der Knoten lassen sich deren Rahmenfarben spezifisch angeben
V(s_sim)[V(s_sim)$name == 6]$color <- "green"
V(s_sim)[V(s_sim)$name == 18]$color <- "red"

plot(s_sim,
     layout=layout_as_star,
     vertex.size=15,
     # vertex.label.cex=2,
     # vertex.frame.color=NA,(muss ausgeschaltet sein, damit die Knoten visualisiert werden können
     edge.arrow.size=.5,
     edge.color="grey80",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu ermöglichen
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     )

title("Gesamtnetzwerk vereinfacht", 
      sub = "beliebteste Knoten in grün (stärkste Beziehungen) und rot (höchste Degrees)",
      cex.main = 2, col.main= "black",
      cex.sub = 2, font.sub = 3, col.sub = "black")


```


```{r Auslesen von Attributen}
# Beispiel für das Vertex-Attribut Geschlecht (von Sandhu)
vertex.attributes(s)$sex
edge.attributes(s)$weight
# wichtig: sind keine Werte gesetzt, dann behandelt igraph den Wert als NA, also not available. Das ist wichtig für die Kalkulation der Netzwerkbeziehungen. Complicated ist ein Wert der sich nur auf das Teilnetzwerk love bezieht und spielt deshalb für die anderen 2x76 Beziehungen keine Rolle. 

```

## Analyse der Teilnetzwerke(von Sandhu)
Die Auswahl der Teilnetzwerke ist abhängig von der jeweiligen Forschungsfrage. Für dieses Netzwerk ist es besonders der Vergleich zwischen Teilnetzwerken interessant. 

Das bedeutet, dass es folgende Teilnetzwerke aufgrund der Edge-Attribute gibt:
1) h3 Hilfsnetzwerk, erste Nennung, d.h. starke Gewichtung (Wert 3)
2) h1 Hilfsnetzwerk, zweite Nennung, d.h. weniger starke Gewichung (Wert 1)
3) h Hilfsnetzwerk mit der Zusammenfassung beider Gewichte über simplifiy()

1) w3 Zusammenarbeit: erste Nennung, d.h. starke Gewichtung (Wert 3)
2) w1 Zusammenarbeit: zweite Nennung, d.h. weniger starke Gewichung (Wert 1)
3) w Zusammenarbeit mit der Zusammenfassung beider Gewichte über simplify()

Das Beziehungsnetzwerk love (l) kennt folgende Ausprägungen:
1) l_pair reziproke Paarbeziehung (1)
2) l_tinder Tinder-Like, muss nicht reziprok sein (2)
3) l_crush einseitig verliebte Situtation (3)

Achtung: die Werte im Teilnetzwerk love sind keine Gewichte, sondern unterschiedliche Beziehungstypen und gelten nur für dieses. Für die Analyse der anderen Beziehungen empfiehlt es sich, das edge.attribut "love" zu löschen.


### Teilnetzwerke nach Beziehungsart (Edge-Attribute)

Das Netzwerk besteht aus drei Beziehungsarten: Ratsuche (zukünftig Teilnetzwerk "h" für help), Zusammenarbeit (zukünftig Teilnetzwerk "w" für work) und Liebesbeziehung (zukünftig Teilnetzwerk "l" für love). Die Teilnetzwerke work und help sind gewichtet, d.h. die erste Nennung einer Person wurde mit 3 codiert und die zweite Nennung mit 1. Das bedeutet, dass jedes Teilnetzwerk über 76 Beziehungen hat (38 Mal eine erste Nennung und 38 Mal eine zweite Nennung). Die Liebesbeziehung wurde nicht gewichtet, sondern nach unterschiedlichen Beziehungsarten unterteilt.

*Generelle Teilnetzwerke*

- help (gesamt)
- work (gesamt)
- love (gesamt)


### ALLE TEILNETZWERKE

```{r Teilnetzwerke erstellen und vereinfachen, message=FALSE, warning=FALSE, paged.print=FALSE}
library(igraph)
## Teilnetzwerke

#{r Teilnetzwerke, fig.height=6, fig.width=10}

#Teilnetzwerke Allgemein

list.edge.attributes(Ida)
edge.attributes(Ida)$country

Ida_person <- delete.vertices(Ida, V(Ida) [type==2])

Ida_orga <- delete.vertices(Ida, V(Ida) [type==1])

#Analyse der Komponenten 

is_connected(Ida_person)
is_connected(Ida_orga)
count_components(Ida_person)
count_components(Ida_orga)

#Mit dem Befehl components teilen wir die Komponenten in Gruppen ein. Das Teilnetzwerk Ida_person besteht nur aus einer Komponente und muss deshalb nicht weiter analysiert werden.
#zeigt uns die Verteilung und die Größe der Komponenten an

co_Ida_orga <- components(Ida_orga)
groups(co_Ida_orga)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_orga)
#wendet die Clusterung auf das Netzwerk an
cluster_Ida_orga <- cluster_walktrap(Ida_orga)
cluster_Ida_orga
#berechnet den Modularitätswert
modularity(cluster_Ida_orga) 
#weist die Mitgliedschaft in die Communities zu
membership(cluster_Ida_orga) 
#visualisiert die Communities
plot(cluster_Ida_orga, Ida_orga, edge.arrow.size=0.1, main="Cluster Ida Organisationen") 

## Jede Organisation bildet ein Cluster, weil diese untereinander nicht verbunden sind und sich anscheinend auch sonst nicht ähnlich sind. Selbst die Womens Suffrage Association und der Alpha Suffrage Club bilden jeweils ihr eigenes Netzwerk, obwohl die beiden Organisationen eine Verbindung haben. 

#Anzahl der Cluster
clusters(Ida_person)
#wendet die Clusterung auf das Netzwerk an
cluster_Ida_person <- cluster_walktrap(Ida_person)
cluster_Ida_person
#berechnet den Modularitätswert
modularity(cluster_Ida_person) 
#weist die Mitgliedschaft in die Communities zu
membership(cluster_Ida_person) 
#visualisiert die Communities
plot(cluster_Ida_person, Ida_person, edge.arrow.size=0.1, main="Cluster Ida Personen") 

## Hier bilden sich im Teilnetzwerk der Personen 8 Cluster. Viele der Personen, die im Gesamtnetzwerk bereits in einem Cluster waren, sind es dieses Mal auch. Das deutet darauf hin, dass diese Personen eine bestimmte Ähnlichkeit haben.

#Teilnetzwerk USA

Ida_USA <- subgraph.edges(Ida, E(Ida)[country==1])

Ida_USA2 <- delete.vertices(Ida_USA, degree(Ida_USA)==0)


plot(Ida_USA2, layout=layout_with_fr,
     main="USA",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

#Analyse der Komponenten 

is_connected(Ida_USA2)
count_components(Ida_USA2)

co_Ida_USA2 <- components(Ida_USA2)
groups(co_Ida_USA2)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_USA2)
#Clusterung 
cluster_Ida_USA2 <- cluster_walktrap(Ida_USA2)
cluster_Ida_USA2
#Modularitätswert
modularity(cluster_Ida_USA2) 
#Mitgliedschaft 
membership(cluster_Ida_USA2) 
#visualisiert die Communities
plot(cluster_Ida_USA2, Ida_USA2, edge.arrow.size=0.1, main="Cluster Ida USA") 

## Das Teilnetzwerk der Beziehungen von Ida in den USA weist 10 verschiedene Cluster auf. Lady Henry Somerset, Frances E. Willard und die Womans Christian Temperance Union sind aus Amerika und deshalb auch in diesem Teilnetzwerk. Ida B. Wells hat sie aber erst in Großbritannien kennengelernt. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Teilnetzwerk GB

Ida_GB <- subgraph.edges(Ida, E(Ida)[country==2])

Ida_GB2 <- delete.vertices(Ida_GB, degree(Ida_GB)==0)

plot(Ida_GB2, layout=layout_with_fr,
     main="Großbritannien",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

#Analyse der Komponenten 

is_connected(Ida_GB2)
count_components(Ida_GB2)

co_Ida_GB2 <- components(Ida_GB2)
groups(co_Ida_GB2)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_GB2)
#Clusterung 
cluster_Ida_GB2 <- cluster_walktrap(Ida_GB2)
cluster_Ida_GB2
#Modularitätswert
modularity(cluster_Ida_GB2) 
#Mitgliedschaft 
membership(cluster_Ida_GB2) 
#visualisiert die Communities
plot(cluster_Ida_GB2, Ida_GB2, edge.arrow.size=0.1, main="Cluster Ida GB") 

## Dieses Teilnetzwerk von den Beziehungen von Ida in Großbritannien zeigt uns lediglich 4 Cluster. Auch hier müssen wir zusammen drüber schauen!!!!!!!!!!!!!!!

#Nebeneinander

par(mfrow=c(1,2), mar=c(0,0,1,2))
plot(Ida_GB, edge.arrow.size=.3, main="GB")
plot(Ida_USA, edge.arrow.size=.3,  main="USA")


```
```{r}
#Unterteilung

#Unterteilung weiblich & männlich

Ida_male <- delete.vertices(Ida, V(Ida) [sex==2])
Ida_female <- delete.vertices(Ida, V(Ida) [sex==1])

#Analyse der Komponenten 

is_connected(Ida_male)
count_components(Ida_male)
co_Ida_male <- components(Ida_male)
groups(co_Ida_male)

is_connected(Ida_female)
count_components(Ida_female)
co_Ida_female <- components(Ida_female)
groups(co_Ida_female)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_male)
#Clusterung 
cluster_Ida_male <- cluster_walktrap(Ida_male)
cluster_Ida_male
#Modularitätswert
modularity(cluster_Ida_male) 
#Mitgliedschaft 
membership(cluster_Ida_male) 
#visualisiert die Communities
plot(cluster_Ida_male, Ida_male, edge.arrow.size=0.1, main="Cluster Ida Männer") 

## Das Teilnetzwerk der Beziehungen von Ida zu Männern hat 8 verschiedene Cluster. Generell fällt die große Anzahl der Männerbeziehungen von Ida in diesem Teilnetzwerk auf. Allerdings sind auch viele Organisationen dabei, weil diese beim Geschlecht keine Angabe haben. Hier müssen wir auch nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!! Vllt auch die Organisationen rausnehmen für einen besseren Überblick.

#Community Analyse
#Anzahl der Cluster
clusters(Ida_female)
#Clusterung 
cluster_Ida_female <- cluster_walktrap(Ida_female)
cluster_Ida_female
#Modularitätswert
modularity(cluster_Ida_female) 
#Mitgliedschaft 
membership(cluster_Ida_female) 
#visualisiert die Communities
plot(cluster_Ida_female, Ida_female, edge.arrow.size=0.1, main="Cluster Ida Frauen") 

## Das Teilnetzwerk der Beziehungen von Ida mit Frauen weist 7 Cluster auf. Das grüne Cluster mit den gelben Knoten sind alles Verbindungen aus Großbritannien. Weitere britische Verbindungen tauchen aber auch im roten Cluster auf in orange. Nochmal drüber schauen zusammen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Unterteilung schwarz & weiss

Ida_black <- delete.vertices(Ida, V(Ida) [skincolor==2])
Ida_white <- delete.vertices(Ida, V(Ida) [skincolor==1])

#Analyse der Komponenten 

is_connected(Ida_black)
count_components(Ida_black)
co_Ida_black <- components(Ida_black)
groups(co_Ida_black)

is_connected(Ida_white)
count_components(Ida_white)
co_Ida_white <- components(Ida_white)
groups(co_Ida_white)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_black)
#Clusterung 
cluster_Ida_black <- cluster_walktrap(Ida_black)
cluster_Ida_black
#Modularitätswert
modularity(cluster_Ida_black) 
#Mitgliedschaft 
membership(cluster_Ida_black) 
#visualisiert die Communities
plot(cluster_Ida_black, Ida_black, edge.arrow.size=0.1, main="Cluster Ida Schwarze") 

## Das Teilnetzwerk der Beziehungen von Ida mit Schwarzen hat 10 Cluster. Mary Church Terrell und Frederick Douglass tauchen wiederholt zusammen in einem Cluster auf. Auch nochmal zusammen anschauen! Oragnisationen raus!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_white)
#Clusterung 
cluster_Ida_white <- cluster_walktrap(Ida_white)
cluster_Ida_white
#Modularitätswert
modularity(cluster_Ida_white) 
#Mitgliedschaft 
membership(cluster_Ida_white) 
#visualisiert die Communities
plot(cluster_Ida_white, Ida_white, edge.arrow.size=0.1, main="Cluster Ida Weiße") 




```
```{r fig.height=14, 5, fig.width=24}

#Teilnetzwerke Unterstützer

Ida_sup <- subgraph.edges(Ida, E(Ida)[relation==2])

Ida_male_sup <- subgraph.edges(Ida_male, E(Ida_male)[relation==2])

Ida_female_sup <- subgraph.edges(Ida_female, E(Ida_female)[relation==2])

Ida_black_sup <- subgraph.edges(Ida_black, E(Ida_black)[relation==2])

Ida_white_sup <- subgraph.edges(Ida_white, E(Ida_white)[relation==2])

#plotting

plot(Ida_male_sup, layout=layout_with_kk,
     main="männliche Unterstützer",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_female_sup, layout=layout_with_kk,
     main="weibliche Unterstützer",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_black_sup, layout=layout_with_kk,
     main="schwarze Unterstützer",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_white_sup, layout=layout_with_kk,
     main="weisse Unterstützer",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

#Analyse der Komponenten 

is_connected(Ida_male_sup)
count_components(Ida_male_sup)
co_Ida_male_sup <- components(Ida_male_sup)
groups(co_Ida_male_sup)

is_connected(Ida_female_sup)
count_components(Ida_female_sup)
co_Ida_female_sup <- components(Ida_female_sup)
groups(co_Ida_female_sup)

is_connected(Ida_black_sup)
count_components(Ida_black_sup)
co_Ida_black_sup <- components(Ida_black_sup)
groups(co_Ida_black_sup)

is_connected(Ida_white_sup)
count_components(Ida_white_sup)
co_Ida_white_sup <- components(Ida_white_sup)
groups(co_Ida_white_sup)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_male_sup)
#Clusterung 
cluster_Ida_male_sup <- cluster_walktrap(Ida_male_sup)
cluster_Ida_male_sup
#Modularitätswert
modularity(cluster_Ida_male_sup) 
#Mitgliedschaft 
membership(cluster_Ida_male_sup) 
#visualisiert die Communities
plot(cluster_Ida_male_sup, Ida_male_sup, edge.arrow.size=0.1, main="Cluster Ida Unterstützer") 

## Das Teilnetzwerk der Unterstützer von Ida B. Wells haben lediglich 3 verschiedene Cluster. Aber warum????!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_female_sup)
#Clusterung 
cluster_Ida_female_sup <- cluster_walktrap(Ida_female_sup)
cluster_Ida_female_sup
#Modularitätswert
modularity(cluster_Ida_female_sup) 
#Mitgliedschaft 
membership(cluster_Ida_female_sup) 
#visualisiert die Communities
plot(cluster_Ida_female_sup, Ida_female_sup, edge.arrow.size=0.1, main="Cluster Ida Unterstützerinnen") 

## Das Teinetzwerk der Unterstützerinnen weist hingegen 5 Cluster auf. Die männlichen Unterstützer von Ida sind zwar mehr, aber die Unterstützerinnen haben mehr kleinere Cluster. Das liegt wahrscheinlich daran, dass die Unterstützerinnen sich eher in Organisationen engagieren.

#Community Analyse
#Anzahl der Cluster
clusters(Ida_black_sup)
#Clusterung 
cluster_Ida_black_sup <- cluster_walktrap(Ida_black_sup)
cluster_Ida_black_sup
#Modularitätswert
modularity(cluster_Ida_black_sup) 
#Mitgliedschaft 
membership(cluster_Ida_black_sup) 
#visualisiert die Communities
plot(cluster_Ida_black_sup, Ida_black_sup, edge.arrow.size=0.1, main="Cluster Ida schwarze Unterstützer:innen") 

## Das Teilnetzwerk der schwarzen Unterstützer:innen von Ida weist nur 4 Cluster auf. Nochmal drüber schauen zusammen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 

#Community Analyse
#Anzahl der Cluster
clusters(Ida_white_sup)
#Clusterung 
cluster_Ida_white_sup <- cluster_walktrap(Ida_white_sup)
cluster_Ida_white_sup
#Modularitätswert
modularity(cluster_Ida_white_sup) 
#Mitgliedschaft 
membership(cluster_Ida_white_sup) 
#visualisiert die Communities
plot(cluster_Ida_white_sup, Ida_white_sup, edge.arrow.size=0.1, main="Cluster Ida weiße Unterstützer:innen") 

## Das Teilnetzwerk der weißen Unterstützer:innen von Ida zeigt uns auch nur vier verschiedene Cluster. Das grüne Cluster mit grünen Knoten sind wieder die Verbindungen aus Großbritannien. Nochmal zusammen anschauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Nebeneinander

par(mfrow=c(1,3), mar=c(0,0,1,2))
plot(Ida_white_sup, edge.arrow.size=.3, main="schwarze Unterstützer:innen")
plot(Ida_black_sup, edge.arrow.size=.3,  main="weiße Unterstützer:innen")
```

```{r}
#Teilnetzwerke Geschäftliche Beziehung

Ida_bus <- subgraph.edges(Ida, E(Ida)[relation==4])

Ida_male_bus <- subgraph.edges(Ida_male, E(Ida_male)[relation==4])
Ida_female_bus <- subgraph.edges(Ida_female, E(Ida_female)[relation==4])

Ida_black_bus <- subgraph.edges(Ida_white, E(Ida_white)[relation==4])
Ida_white_bus <- subgraph.edges(Ida_black, E(Ida_black)[relation==4])



#plotting

Ida_male_bus
Ida_female_bus
Ida_black_bus
Ida_white_bus

plot(Ida_male_bus, layout=layout_with_kk,
     main="männliche Geschäftsbzeihungen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_female_bus, layout=layout_with_kk,
     main="weibliche Geschäftsbeziehungen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_black_bus, layout=layout_with_kk,
     main="Geschäftsbeziehungen mit Schwarzen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_white_bus, layout=layout_with_kk,
     main="Geschäftsbeziehungen mit Weißen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

#Analyse der Komponenten 

is_connected(Ida_male_bus)
count_components(Ida_male_bus)
co_Ida_male_bus <- components(Ida_male_bus)
groups(co_Ida_male_bus)

is_connected(Ida_female_bus)
count_components(Ida_female_bus)
co_Ida_female_bus <- components(Ida_female_bus)
groups(co_Ida_female_bus)

is_connected(Ida_black_bus)
count_components(Ida_black_bus)
co_Ida_black_bus <- components(Ida_black_bus)
groups(co_Ida_black_bus)

is_connected(Ida_white_bus)
count_components(Ida_white_bus)
co_Ida_white_bus <- components(Ida_white_bus)
groups(co_Ida_white_bus)

#Community Analyse
#Anzahl der Cluster
clusters(Ida_male_bus)
#Clusterung 
cluster_Ida_male_bus <- cluster_walktrap(Ida_male_bus)
cluster_Ida_male_bus
#Modularitätswert
modularity(cluster_Ida_male_bus) 
#Mitgliedschaft 
membership(cluster_Ida_male_bus) 
#visualisiert die Communities
plot(cluster_Ida_male_bus, Ida_male_bus, edge.arrow.size=0.1, main="Cluster Ida Geschäftspartner") 

## Das Teilnetzwerk der Geschäftspartner von Ida hat 6 verschiedene Cluster. Jim Wells und Dr. Gray sind auch in diesem Netzwerk, weil sie untereinander eine geschäftliche Beziehung haben, aber keine zu Ida. Nochmal zusammen anschauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_female_bus)
#Clusterung 
cluster_Ida_female_bus <- cluster_walktrap(Ida_female_bus)
cluster_Ida_female_bus
#Modularitätswert
modularity(cluster_Ida_female_bus) 
#Mitgliedschaft 
membership(cluster_Ida_female_bus) 
#visualisiert die Communities
plot(cluster_Ida_female_bus, Ida_female_bus, edge.arrow.size=0.1, main="Cluster Ida Geschäftsparterinnen") 

## Das Teilnetzwerk von den Geschäftspartnerinnen von Ida zeigt 4 verschiedene Cluster auf. Nochmal alle zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_black_bus)
#Clusterung 
cluster_Ida_black_bus <- cluster_walktrap(Ida_black_bus)
cluster_Ida_black_bus
#Modularitätswert
modularity(cluster_Ida_black_bus) 
#Mitgliedschaft 
membership(cluster_Ida_black_bus) 
#visualisiert die Communities
plot(cluster_Ida_black_bus, Ida_black_bus, edge.arrow.size=0.1, main="Cluster Ida schwarze Geschäftspartner:innen") 

## Das Teilnetzwerk der schwarzen Geschäftsparter:innen von Ida stellt 4 verschiedene Cluster dar. Auch hier gibt es wieder 2 Cluster die keine geschäftliche Beziehung zu Ida besitzen, aber wiederum untereinander. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_white_bus)
#Clusterung 
cluster_Ida_white_bus <- cluster_walktrap(Ida_white_bus)
cluster_Ida_white_bus
#Modularitätswert
modularity(cluster_Ida_white_bus) 
#Mitgliedschaft 
membership(cluster_Ida_white_bus) 
#visualisiert die Communities
plot(cluster_Ida_white_bus, Ida_white_bus, edge.arrow.size=0.1, main="Cluster Ida weiße Geschäftspartner:innen") 

## Beim Teilnetzwerk der weißen Geschäftsparter:innen von Ida hingegen sind es 6 Cluster. Auch hier gibt es Knoten die keine geschäftliche Beziehung zu Ida haben, aber geschäftliche Beziehungen zu Knoten aus anderen Clustern. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

```

```{r}

#Teilnetzwerk nach Aufgabenbereich

Ida_jour <- delete.vertices(Ida, V(Ida) [Journalismus==0])

Ida_act <- delete.vertices(Ida, V(Ida) [Aktivismus==0])

Ida_pol <- delete.vertices(Ida, V(Ida) [Politik==0])

Ida_jour_act <- delete.vertices(Ida_jour, V(Ida_jour)[Aktivismus==0])

#plotting

plot(Ida_jour, layout=layout_with_kk,
     main="Beziehungen zu Journalisten",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_act, layout=layout_with_kk,
     main="Beziehungen zu Aktivisten",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_pol, layout=layout_with_kk,
     main="Beziehungen zu Politikern",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_jour_act, layout=layout_with_kk,
     main="Beziehungen zu aktivistischen Journalisten",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

#Analyse der Komponenten 

is_connected(Ida_jour)
count_components(Ida_jour)
co_Ida_jour <- components(Ida_jour)
groups(co_Ida_jour)

is_connected(Ida_act)
count_components(Ida_act)
co_Ida_act <- components(Ida_act)
groups(co_Ida_act)

is_connected(Ida_pol)
count_components(Ida_pol)
co_Ida_pol <- components(Ida_pol)
groups(co_Ida_pol)

is_connected(Ida_jour_act)
count_components(Ida_jour_act)
co_Ida_jour_act <- components(Ida_jour_act)
groups(co_Ida_jour_act)


#Community Analyse
#Anzahl der Cluster
clusters(Ida_jour)
#Clusterung 
cluster_Ida_jour <- cluster_walktrap(Ida_jour)
cluster_Ida_jour
#Modularitätswert
modularity(cluster_Ida_jour) 
#Mitgliedschaft 
membership(cluster_Ida_jour) 
#visualisiert die Communities
plot(cluster_Ida_jour, Ida_jour, edge.arrow.size=0.1, main="Cluster Ida Journalist:innen") 

## Das Teilnetzwerk der Beziehungen zu Journalist:innen hat 5 verschiedene Cluster. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_act)
#Clusterung 
cluster_Ida_act <- cluster_walktrap(Ida_act)
cluster_Ida_act
#Modularitätswert
modularity(cluster_Ida_act) 
#Mitgliedschaft 
membership(cluster_Ida_act) 
#visualisiert die Communities
plot(cluster_Ida_act, Ida_act, edge.arrow.size=0.1, main="Cluster Ida Aktivist:innen") 

## Das Teilnetzwerk der Beziehungen zu Aktivist:innen zeigt uns 7 verschiedene Cluster. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_pol)
#Clusterung 
cluster_Ida_pol <- cluster_walktrap(Ida_pol)
cluster_Ida_pol
#Modularitätswert
modularity(cluster_Ida_pol) 
#Mitgliedschaft 
membership(cluster_Ida_pol) 
#visualisiert die Communities
plot(cluster_Ida_pol, Ida_pol, edge.arrow.size=0.1, main="Cluster Ida Politiker:innen") 

## Das Teilnetzwerk der Beziehungen zu Politiker:innen stellt lediglich 3 verschiedene Cluster dar, wobei ein Cluster nur die National American Woman Suffrage Association umschließt. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_jour_act)
#Clusterung 
cluster_Ida_jour_act <- cluster_walktrap(Ida_jour_act)
cluster_Ida_jour_act 
#Modularitätswert
modularity(cluster_Ida_jour_act) 
#Mitgliedschaft 
membership(cluster_Ida_jour_act) 
#visualisiert die Communities
plot(cluster_Ida_jour_act, Ida_jour_act, edge.arrow.size=0.1, main="Cluster Ida Journalist:innen & Aktivist:innen") 

## Das Teilnetzwerk der Beziehungen zu Journalist:innen und Aktivist:innen zusammen clustert nur zweimal. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Nebeneinander

par(mfrow=c(1,3), mar=c(0,0,1,2))
plot(Ida_jour, edge.arrow.size=.3, main="Journalist:innen")
plot(Ida_act, edge.arrow.size=.3,  main="Aktivist:innen")
plot(Ida_pol, edge.arrow.size=.3,  main="Politiker:innen")

```
```{r}

#Teilnetzwerk nach Motivation

Ida_mot <- delete.vertices(Ida, V(Ida) [type==2])

Ida_mot_both <- delete.vertices(Ida_mot, V(Ida_mot) [motivation==0])
Ida_mot_both1 <- delete.vertices(Ida_mot_both, V(Ida_mot_both) [motivation==4])
Ida_mot_both2 <- delete.vertices(Ida_mot_both1, V(Ida_mot_both1) [motivation==1])
Ida_mot_both3 <- delete.vertices(Ida_mot_both2, V(Ida_mot_both2) [motivation==2])


Ida_mot_black <- delete.vertices(Ida_mot_both1, V(Ida_mot_both1) [motivation==2])


Ida_mot_woman <- delete.vertices(Ida_mot_both1, V(Ida_mot_both1) [motivation==1])

#plotting

plot(Ida_mot_black, layout=layout_with_kk,
     main="Einsatz für Rechte von Schwarzen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_mot_woman, layout=layout_with_kk,
     main="Einsatz für Rechte von Frauen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

plot(Ida_mot_both3, layout=layout_with_kk,
     main="Einsatz für Rechte von Schwarzen und Frauen",
     edge.arrow.size=.7,
     edge.width=E(Ida)$weight,
     edge.color="black")

#Analyse der Komponenten 

is_connected(Ida_mot_black)
count_components(Ida_mot_black)
co_Ida_mot_black <- components(Ida_mot_black)
groups(co_Ida_mot_black)

is_connected(Ida_mot_woman)
count_components(Ida_mot_woman)
co_Ida_mot_woman <- components(Ida_mot_woman)
groups(co_Ida_mot_woman)

is_connected(Ida_mot_both3)
count_components(Ida_mot_both3)
co_Ida_mot_both3 <- components(Ida_mot_both3)
groups(co_Ida_mot_both3)


#Community Analyse
#Anzahl der Cluster
clusters(Ida_mot_black)
#Clusterung 
cluster_Ida_mot_black <- cluster_walktrap(Ida_mot_black)
cluster_Ida_mot_black
#Modularitätswert
modularity(cluster_Ida_mot_black) 
#Mitgliedschaft 
membership(cluster_Ida_mot_black) 
#visualisiert die Communities
plot(cluster_Ida_mot_black, Ida_mot_black, edge.arrow.size=0.1, main="Cluster Motivation Schwarzenrechte") 

## Das Teilnetzwerk der Beziehungen zu Knoten mit dem Einsatz für die Rechte der Schwarzen weist 5 verschiedene Cluster auf. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_mot_woman)
#Clusterung 
cluster_Ida_mot_woman <- cluster_walktrap(Ida_mot_woman)
cluster_Ida_mot_woman
#Modularitätswert
modularity(cluster_Ida_mot_woman) 
#Mitgliedschaft 
membership(cluster_Ida_mot_woman) 
#visualisiert die Communities
plot(cluster_Ida_mot_woman, Ida_mot_woman, edge.arrow.size=0.1, main="Cluster Motivation Frauenrechte") 

## Das Teilnetzwerk der Beziehungen zu Knoten mit dem Einsatz für Frauenrechte stellt 4 verschiedene Cluster dar. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Community Analyse
#Anzahl der Cluster
clusters(Ida_mot_both3)
#Clusterung 
cluster_Ida_mot_both3 <- cluster_walktrap(Ida_mot_both3)
cluster_Ida_mot_both3
#Modularitätswert
modularity(cluster_Ida_mot_both3) 
#Mitgliedschaft 
membership(cluster_Ida_mot_both3) 
#visualisiert die Communities
plot(cluster_Ida_mot_both3, Ida_mot_both3, edge.arrow.size=0.1, main="Cluster Motivation Schwarzen- und Frauenrechte") 

## Das Teilnetzwerk der Beziehungen zu Knoten, die sich für Schwarzen- und Frauenrechte gleichermaßen einsetzen, zeigt 3 verschiedene Cluster auf. Nochmal zusammen drüber schauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#Nebeneinander

par(mfrow=c(1,3), mar=c(0,0,1,2))
plot(Ida_mot_black, edge.arrow.size=.3, main="Schwarzenrechtler:innen")
plot(Ida_mot_woman, edge.arrow.size=.3,  main="Frauenrechtler:innen")
plot(Ida_mot_both2, edge.arrow.size=.3,  main="Beides")

```
### TEILNETZWERKE ENDE


```

Damit die Netzwerke gut vereinfacht werden können sollten die ungenutzen edge-attribute wie relation oder complicated gelöscht werden, damit die jeweiligen Hauptnetzwerke eigenständig verglichen werden können.

```{r Nicht benötigte Edge-Attribute löschen, message=TRUE, warning=FALSE, paged.print=TRUE}
library(igraph)

# Nicht benötigte Edge-Attribute löschen
# In den Teilnetzwerken sind edge-Attribute vorhanden, die wir für eine weitere Vereinfachung des Netzwerks nicht benötigen. Das gilt v.a. für die Teilnetzwerke work und help.

work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")

help <- delete_edge_attr(help, "relation")
help <- delete_edge_attr(help, "complicated")

love <- delete_edge_attr(love, "relation")
# bei love bleibt die Kategorie complicated erhalten, da sich diese ja direkt auf die Art der Liebesbeziehung bezieht. Bei erstellten Liebesnetzwerk werden auch alle Knoten gelöscht, die keine Beziehungskategorie haben, d.h. das Netzwerk ist automatisch kleiner. 

#edge.attributes(love)$complicated

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Dafür lassen sich die Beziehungsstärken aber besser abbilden. Dies ist später für die Analyse von dyadischen Beziehungen wichtig.
# 
is_simple(work)
w_sim <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(w_sim)
w_sim

is_simple(help)
h_sim <- simplify(help,edge.attr.comb=list(weight="sum"))
is_simple(h_sim)
h_sim

```
 
```{r Vergleich der drei Netzwerke, message=FALSE, warning=FALSE, paged.print=TRUE}

# Vergleich der drei vereinfachte Netzwerke
par(mfrow=c(1,3), mar=c(2,0,2,0)) 

plot(w_sim, layout=layout_nicely,
     edge.arrow.size=.2,
     edge.color="blue",
     edge.width=E(w_sim)$weight,
     vertex.color="grey75",
     vertex.frame.color=NA,
     main=" Teilnetzwerk: Zusammenarbeit",
     sub="38 Knoten mit 75 Kanten")
plot(h_sim, layout=layout_nicely, 
     edge.arrow.size=.2,
     edge.color="green",
     edge.width=E(h_sim)$weight,
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Teilnetzwerk: Ratsuche",
     sub="38 Knoten mit 75 Kanten")
plot(love, layout=layout_nicely, 
     edge.arrow.size=.2,
     edge.color="red",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Teilnetzwerk: Liebe",
     sub="23 Knoten mit 24 Kanten")

# setzt die Darstellung wieder auf eine Abbildung zurück
par(mfrow=c(1,1), mar=c(0,0,0,0))

```

*Teilnetzwerke nach Gewichtung im Vergleich*
Eine weitere Form der Analyse wäre es, die Teilnetzwerke work oder help nach der ersten und zweiten Nennung zu unterteilen. Mit der Annahme, dass die erste Nennung (und damit das Kantengewicht 3) eine höhere Popularität hat als die zweite Nennung lassen sich ggf. Dynamiken innerhalb des Netzwerks aufzeigen.

```{r Teilnetzwerke anhand des Kantengewichts vergleichen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

work <- subgraph.edges(s, E(s)[relation==1]) 
work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")
list.edge.attributes(work)
edge.attributes(work)$weight

# aggregiertes Netzwerk
is_simple(work)
ws <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(ws)
ws

# unterteilt das Netzwerk in das Hilfsnetzwerk h1 mit einem Gewicht von 1
w1 <- subgraph.edges(work, E(work)[weight==1])
# analog dazu das Hilfsnetzwerk mit einem Gewicht von 3
w3 <- subgraph.edges(work, E(work)[weight==3])
# Vergleich der beiden Netzwerke
w1
w3
ws
# jedes Netzwerk hat jetzt genau 38 Knoten mit 38 Kanten

# die beiden getrennten Netzwerke lassen sich nun einfach mit einer Addition wieder in das ursprüngliche Netzwerk zurückversetzen:
wadd <- w1 + w3
wadd


par(mfrow=c(1,4), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(w3, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="starke Zusammenarbeit, \n Gewicht 3")

plot(w1, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="lightblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n Gewicht 1")

plot(ws, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="blue",
     edge.width=E(s)$weight, # definiert die Kantenstarke nach Gewicht
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n simplifiziert, gewichtet")

plot(wadd, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="black",
     edge.width=E(wadd)$weight, # definiert die Kantenstarke nach Gewicht
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n addierte Teilnetzwerke")

# setzt die Ansicht wieder auf einen Graph pro Zeile zurück
par(mfrow=c(1,1), mar=c(0,0,1,2))

```

Interessant in der Analyse ist, dass die bis dahin zweite Komponente aus den Knoten 5,6,12,14,22,26 bei der ersten Nennung noch zusammenbleibt, bei der zweiten Nennung aber in zwei kleinere Komponenten zerfällt (5,22) und (6,12,14,26). Das bedeutet, dass die Dyade 5 und 22 sich sowohl bei der ersten als auch zweiten Nennung beides mal genannt hat. Folglich müsste das Gewicht des aufaddierten Netzwerks bei dieser Dyade den Wert 6 haben. 

Ingesamt zeigt die Analyse, dass die Präferenzen für die Zusammenarbeit sich deutlich stärker zerlegen lässt, wenn man die Teilnetzwerke nach Gewicht erhebt. 

*Teilnetzwerk Beziehung im Vergleich*

```{r Teilnetzwerk love anhand des Kantengewichts vergleichen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

love <- subgraph.edges(s, E(s)[relation==3]) 
love
list.edge.attributes(love)

# Das Attribut "complicated" gibt drei Beziehungsarten an, mit denen das Netzwerk weiter unterteilt werden kann.

# Paarbeziehung im Netzwerk love
l_pair <- subgraph.edges(love, E(love)[complicated==1])
# Tinder-Swipe im Netzwerk love
l_tinder <- subgraph.edges(love, E(love)[complicated==2])
# Crush im Netzwerk love
l_crush <- subgraph.edges(love, E(love)[complicated==3])

# Vergleich der beiden Netzwerke
love
l_pair
l_tinder
l_crush

par(mfrow=c(1,4), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(love, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="alle Beziehungen")

plot(l_pair, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="red",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Paarbeziehungen")

plot(l_tinder, layout=layout_with_kk,
     edge.arrow.size=.5,
     edge.color="pink",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Tinder-Swipe")

plot(l_crush, layout=layout_with_kk,
     edge.arrow.size=.5,
     edge.color="lightgreen",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Crush")

# setzt die Ansicht wieder auf einen Graph pro Zeile zurück
par(mfrow=c(1,1), mar=c(0,0,1,2))

```

Durch die Teilnetzwerke wird deutlich, dass bei den Paarbeziehungen zwei Triaden vorliegen (16,28,29) und (6,5,22). Entweder haben 28 und 5 jeweils eine Affäre oder sie neigen zur Polyamorie. Die Tinder-Beziehungen (swipes) scheinen nicht stark ausgeprägt zu sein (4 von 38 Befragten haben angegeben, dass sie auf Tinder aktiv sind). Davon mögen sich 33 und 9 gegenseitig auf Tinder und sind auch in einer Beziehung. 31 findet 19 attraktiv, aber nicht umgekehrt. Sehr begehrt im Semester scheint Knoten 23 zu sein, der fünf (heimliche) crushes hat. Knoten 23 findet aber wiederum 17 interessant. Knoten 6 hat zwei crushes. Knoten 16 mag Knoten 18, aber Knoten 18 findet wiederum Knoten 23 attraktiv: eine vertrackte Situation! 

### Teilnetzwerke nach Node-Attributen
Die Analyse der Teilnetzwerke nach Node-Attributen werden hier nur exemplarisch am Beispiel Geschlecht und Vertiefungsrichtung gezeigt. Der einfachste Weg ein Teilnetzwerk zu erstellen geht über den Befehl delete.vertices(). Damit werden alle Knoten samt Verbindungen gelöscht, die bestimmte Bedingungen erfüllen. Wenn die Node-Attribute numerisch codiert sind lassen sich logische Operatoren einsetzen.

*Teilnetzwerk Geschlecht*

```{r Teilnetzwerk nach Node-Attribut Geschlecht, fig.height=6, fig.width=10, message=FALSE, warning=FALSE, paged.print=TRUE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

list.vertex.attributes(s)
vertex_attr(s)$sex

s_fem <- delete_vertices(s, V(s)[sex > "1"]) 
s_fem
plot(s_fem, layout=layout_with_kk,
     main="Gesamtnetzwerk: weibliche Akteure",
     edge.color="pink",
     edge.arrow.size=.3,
     vertex.color="pink",
     vertex.frame.color=NA,
     sub="n=29, 110 Kanten")
```

Bereits hier zeigt sich, dass das Netzwerk drei Komponenten zerfällt. Neben die zweite kleinere Komponente (die nur aus Frauen besteht) kommt noch eine kleine Dyade hinzu. 

*Kombination von Node-Attributen*
In diesem Beispiel lassen sich z.B. Geschlecht und Vertiefungsrichtung kombinieren. Die Analyse der jeweiligen Kategorien folgt dabei dem Forschungsziel.

```{r Kombination Geschlecht und Vertiefungsrichtung}
list.vertex.attributes(s)

# Zunächst werden alle Werte gelöscht, die nicht weiblich sind (eins ist als weiblich codiert, also logischer Operator wird > verwendet, d.h. es werden alle männlichen und diversen Knoten gelöscht)
s_fem <- delete_vertices(s, V(s)[sex >"1"]) 

# Dann werden die Journalisten mit dem Wert ein 1 (weil 1 als CR Vertiefung codiert ist) aus dem Netzwerk s_fem gelöscht (in dem nur Frauen sind.)
s_fem_pr <- delete_vertices(s_fem, V(s_fem)[crpr=="1"]) 
s_fem_pr

# Der plot verwendet nur wenig Anpassungen.
plot(s_fem_pr, 
     layout=layout_with_kk,
     main="Netzwerk der PR-Vertieferinnen",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.label.color="grey30",
     vertex.color="pink",
     vertex.frame.color=NA,
     sub="n=17, 48 Kanten, alle Beziehungsarten")
```


### Kombination von Edge- und Nodeattributen
Teilnetzwerke lassen sich auch aus einer Kombination von Edge- und Node-Attributen erstellen. Dazu werden die oben genannten Schritte kombiniert. 

*Teilnetzwerk Männer im Hilfsnetzwerk im Altersvergleich*

```{r Teilnetzwerk Frauen und Hilfsnetzwerk im Altervergleich}

# alle Schritte zur Erstellung des Teilnetzwerks

# 1. Netzwerk einlesen
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# 2. Teilnetzwerk Ratsuche generieren
help <- subgraph.edges(s, E(s)[relation==2])

# 3. Männer herausfiltern
vertex_attr(help)$sex
help_male <- delete_vertices(help, V(help)[sex != "2"]) 
help_male

# 4. Altersstruktur anzeigen
vertex.attributes(help_male)$age
# Hier bietet es sich an, das Netzwerk in zwei Teilnetzwerke zu unterteilen, damit das Netzwerk nicht zu unübersichtlich wird.

help_male_young <- delete_vertices(help_male, V(help_male)[age>"2"]) 
help_male_old <- delete_vertices(help_male, V(help_male)[age<"3"]) 

help_male_young
help_male_old

# Visualisierung im Vergleich
par(mfrow=c(1,2), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(help_male_young, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="skyblue",
     vertex.color="skyblue",
     vertex.frame.color=NA,
     vertex.label.color="white",
     main="junge Männer auf Ratsuche")

plot(help_male_old, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="blue",
     vertex.color="blue",
     vertex.frame.color=NA,
     vertex.label.color="white",
     main="ältere Männer auf Ratsuche")

par(mfrow=c(1,1), mar=c(0,0,4,0))

```

Interpretation: Bei den jüngeren Männern fragt 31 Knoten 11 um Rat, bei den älteren Männern fragt Knoten 9 Knoten 10 um Rat. Die isolierten Knoten fragen weibliche Knoten um Rat. 


## Teilnetzwerke: Componenten, Cluster und Cliquen
Die Analyse hat Teilnetzwerke nach spezifischen Kriterien generiert. Jedes Netzwerk verfügt aber auch über spezielle Eigenarten, wenn sich Knoten nach bestimmten Kriterien zusammenfinden. 

Auf der Ebene des Netzwerks sind die Komponenten: Wenn keine isolierten Knoten existieren und alle Knoten in einem Hauptnetzwerk verbunden sind, dann liegt ein Netzwerk mit einer Komponente vor. Die Prüfung erfolgt mit dem Befehl is_connected(g). Achtung: manche Berechnungen von Netzwerkmaßen sind nur bei Netzwerken möglich, die aus einer Komponente bestehen. 


### Komponenten

__Komponenten analysieren__
Mit der Visualisierung sehen wir, dass das Studierendennetzwerk aus zwei Komponenten besteht: einer großen Hauptkomponente und einer kleineren Komponente aus sechs Knoten. Da insbesondere bei großen Netzwerken die Teilkomponenten nicht immer sichtbar sind, ist es hilfreich zu Beginn der Analyse sich alle Komponenten anzeigen zu lassen Der Befehl groups() zeigt an, welche Knoten zu welcher Komponente gehören. 

```{r Komponenten analysieren}
# Anzahl der Komponenten
count_components(s)

# Um genauer zu verstehen, welche Vertices zu welcher Gruppe gehören, lassen sie sich mit dem Befehl groups(g) in Grupppen unterteilten. 
s_groups <- groups(components(s))
s_groups
```

__Starke und schwache Komponenten__
Netzwerke lassen sich in starke und schwache Komponenten analysieren. Dazu prüft man zunächst, ob es sich um eine Komponente handelt und zerlegt diese dann in eine starke und schwache Komponente. Stark bedeutet hier, dass es sich um einen Teilcommunities mit einer höheren Dichte handelt.

```{r Starke und schwache Komponenten}
# Unteranalyse der Hauptkomponente
is_connected(s)

# Analyse der Verteilung der Komponenenten
components(s, mode = c("weak", "strong"))

# Analyse der starken Komponenten
components(s, mode = "strong")

# Anzahl der Komponenten
count_components(s)

# Aufteilung der Komponenten
comp_s <- components(s)
groups(comp_s)
```


```{r Prüfung verbundener Cluster}
# Anzahl der Clusters
clusters(s)

# Sind die Cluster miteinander verbunden?
is_connected(s)
```

Die Analyse zeigt: das Netzwerk besteht aus zwei nicht miteinander verbundenen Clustern, die aus 32 und 6 Knoten bestehen.

__Netzwerk in Komponenten zerlegen__
Um Netzwerke in einzelne Componenten oder Cluster zu zerlegen verwenden wir den Befehl decompose.graph(g). Wir wissen, dass das Netzwerk zwei Cluster oder Componenten hat, die ausgegeben werden. Danach lassen sich die Cluster getrennt auftrennen, als neue igraph-Objekte umschreiben und visualisieren.


```{r Komponenten berechnen und isolieren}
library(igraph)
# Netzwerk erstellen und vereinfachen
el <- read.csv("https://raw.githubusercontent.com/NiclasReichelt/Ida-Wells/main/Ida%20Wells%20-%20Ego%20-%20Finale%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/NiclasReichelt/Ida-Wells/main/Ida%20Wells%20-%20Ego%20-%20Finale%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Vereinfachtes Hauptnetzwerk von Sandhu 
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim)
## Analyse der Komponenten
# Zunächst prüfen wir, ob das Netzwerk überhaupt zusammenhängend ist
is_connected(s_sim)

#Komponenten in Gruppen unterteilen 
#Zeigt die Verteilung und die Größe der Komponenten an 
co <- components(ss)
co

# Dabei zeigt sich, dass das Netzwerk aus zwei Komponenten besteht
groups(co)


# Komponenten auftrennen
s_comp <- decompose.graph(s_sim)
s_comp

# Komponenten neu benennen
s_comp1 <- s_comp[[1]]
s_comp2 <- s_comp[[2]]

# neue Teilkomponenten analysieren
s_comp1
s_comp2

# Die Komponenten in einer Visualisierung vergleichen

# Visualisierung im Vergleich
par(mfrow=c(1,2), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(s_comp1, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Hauptkomponente")

plot(s_comp2, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="tomato",
     vertex.color="tomato",
     vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp2),
     main="kleinere Komponente")

par(mfrow=c(1,1), mar=c(0,0,4,0))

```

Relevanz von Komponenten
Die Aufteilung in Komponenten ist wichtig, weil dadurch Netzwerkmaße beeinflusst werden.

```{r Komponenten im Vergleich am Beispiel Dichte}

# Dichteberechnungen im Vergleich
edge_density(s_sim)
edge_density(s_comp1)
edge_density(s_comp2)
```

Beispielsweise zeigt die Berechnung der Dichte im Netzwerk, dass im Gesamtnetzwerk s_sim eine Dichte von 8,8% vorliegt, die Hauptkomponente aber eine Dichte von 11,92% und die Teilkomponente eine Dichte von 40% besitzt. Dies bedeutet, dass die Teilkomponente deutlich stärker vernetzt ist als die Hauptkomponente.

*Merke*: Bei der Berechnung von Netzwerkmaßen und deren Vergleiche immer sicherstellen, dass die Bezüge der Netzwerke zueinander auch gewahrt bleiben.


### Cluster

Innerhalb von Komponenten lassen sich verschiedne Teilcluster berechnen. Wir verwenden dafür die Hauptkomponente und berechnen Cluster innerhalb der Komponente. Der *cluster_walktrap(g)* Befehl berechnet die Cluster anhand der kürzesten Pfade und einem statistischen Vergleich zwischen den Clustern. Der Vorteil dieser Methode ist, dass die Ausgabe des Plots die Cluster gleich farbig zuteilt (diese Zuweisung ist beliebig und kann nicht verändert werden). Für die Berechnung werden Teilbeziehungen der Unternetzwerke zueinander in Verhältnis gesetzt, die Visualisierung verbindet diese wieder in einer Gesamtdarstellung. 

```{r Clusterberechnung Walktrap}

# Anzahl der Cluster
clusters(s_sim)

# Clusterberechnung
plot(s_comp1, vertex.color="lightblue", main="Komponente 1")

# Wie funktioniert der Befehl?
css <- cluster_walktrap(ss)
css
modularity(css)
membership(css)
plot(css, ss, edge.arrow.size=0.1, main="clustergesamt")

# Berechnung der Cluster innerhalb der Komponente
# erstellt die Berechnung für die Modularität und deren Teilgruppen
cl <- cluster_walktrap(s_comp1)
modularity(cl)
membership(cl)

plot(cl, s_comp1,
     edge.arrow.size=.2,
     main="Cluster-Walktrap Analyse von s_comp1")
```

*Merke*: Netzwerke können in Teilnetzwerke und Communities zerlegt werden. Die Tiefe der Analyse ist abhängig von der Forschungsfrage. 

### Communities berechnen
Für die Berechnung von *communities* werden automatisch nach dichten Untergruppen im Netzwerk gesucht. Die Annahme ist, dass eine hohe Dichte zwischen Knoten für viel Austausch oder Kontakt steht und dies eine Gemeinschaft (community) innerhalb des Netzwerks definiert, die sich von anderen abgrenzen lässt.

```{r Communities erstellen}
# Anzahl der Clusters
clusters(s)

# Komponenten auftrennen
s_comp <- decompose.graph(s)
s_comp

# Komponenten neu benennen
s_comp1 <- s_comp[[1]]


# Berechnung der Cluster innerhalb der Komponente
# erstellt die Berechnung für die Modularität und deren Teilgruppen
cl <- cluster_walktrap(s_comp1)
modularity(cl)
membership(cl)

# Clusterberechnung
plot(s_comp1,
     edge.arrow.size=.3,
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Komponente 1 (via communities")

# Berechnung der Cluster innerhalb der Komponente

# Was macht der communities Befehl?
?communities()

# Wir verwenden die oben erstellte Aufteilung der Cluster
membership(cl)

# mit dem Befehl sizes wird die Größe der jeweiligen Communities angezeigt
sizes(cl)

# und communities() liefert eine Zuordnung der jeweiligen Knoten auf die Communities
communities(cl)

# Achtung: das sind keine igraph-Objekte, sondern nur die Angaben der Knoten. 
```

Es gibt noch weitere Clustering-Verfahren, die Cluster nach unterschiedlichen Kriterien bilden. Der Algorithmus von cluster_edge_betweeness() geht davon aus, dass sich sich Cluster vor allem an den "Sollbruchstellen" eines Netzwerks trennen lassen. Diese werden über den Wert der Betweenness berechnet, also die Knoten, die in hohem Maße für die Verbindung zu anderen Knoten beitragen. 

```{r Cluster-Betweeness erstellen}
# Clusterberechnung
plot(s_comp1, vertex.color="grey80", main="Komponente 1")

# Berechnung der Cluster innerhalb der Komponente
?cluster_edge_betweenness()

# erstellt die Berechnung für die Modularität und deren Teilgruppen
eb <- cluster_edge_betweenness(s_comp1)
eb

plot(eb, s_comp1,
     edge.arrow.size=.2,
     main="Edge-Betweenness Cluster")
```

*Vergleich von Walktrap und Edge-Betweenness-Clustern*
Bei der Analyse von Clustern ist es notwendig zu verstehen, welche Art von Cluster berechnet wird. 

```{r Vergleich Walktrap und Edge-Betweeness}
# Clusterberechnung
plot(s_comp1, vertex.color="grey80", main="Komponente 1")

# Berechnung Walktrap-Methode
cl <- cluster_walktrap(s_comp1)

# erstellt die Berechnung für die Modularität und deren Teilgruppen
eb <- cluster_edge_betweenness(s_comp1)
eb

# Visualisierung im Vergleich

par(mfrow=c(1,2), mar=c(0,0,2,1)) 
plot(eb, s_comp1, edge.arrow.size=.2, main="Walktrap-Cluster")
plot(cl, s_comp1, edge.arrow.size=.2, main="Edge-Between-Cluster")
par(mfrow=c(1,1), mar=c(0,0,2,1)) 
```

*Merke*: Das Ergebnis einer Clusteranalyse unterscheidet sich durch die jeweils eingesetzten Funktionen. Achten Sie deshalb darauf, ob der entsprechende Algorithmus zu ihrer Forschungfrage passt

### Dyaden und Reziprozität
Dyaden sind wichtige Bausteine für Netzwerke. Bei gerichteten Netzwerken lässt sich hier das Maß der Reziprozität berechnen.

```{r Dyadenzenus vereinfachtes Gesamtnetzwerk, fig.height=6, fig.width=10, message=FALSE, warning=FALSE, paged.print=TRUE}

# Wir erstellen ein vereinfachtes Gesamtnetzwerk
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim)

# Durchführung des Dyadenzensus
dyad_census(s_sim)

# Ausgabe der dyadischen Beziehungen nach dem MAN-Schema
# M = Mutal (reziprok)
# A = Asymmetrical (einseitig gerichtet)
# N = Null (keine Beziehung)

# Berechnung der Reziprozität
reciprocity(s_sim, mode="ratio")
# Der berechnete Wert gibt das Verhältnis von reziproken Beziehungen zu normalen Beziehungen an, in diesem Fall sind 26,08% der Beziehungen im Netzwerk reziprok.

# Genauere Analyse der reziproken Beziehungen
# Der Befehl which_mutual gibt genau an, bei welchen Knoten es sich um eine reziproke Beziehung handelt.

m <- which_mutual(s_sim, es = E(s_sim))
m

# Wir schreiben jetzt die Werte als Edge-Attribute in die Edgelist
E(s_sim)$reciprocity <- m
edge.attributes(s_sim)

# Wir müssen jetzt noch die Werte der Edge-Attribute in der Spalte "reciprocity" in logische Operatoren umwandeln:

E(s_sim)$reciprocity  <- as.numeric(E(s_sim)$reciprocity)
edge.attributes(s_sim)$reciprocity

# Plot der reziproken Beziehungen
plot(s_sim, 
     asp=0,
     layout = layout_with_kk, 
     edge.arrow.mode=3,
     edge.arror.size=.2,
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     vertex.color=NA,
     vertex.frame.color=NA,
     #edge.width=E(s_sim)$weight/2, 
     edge.color=c("red", "NA")[(E(s_sim)$reciprocity=="0")+1],
     main="vereinfachtes Gesamtnetzwerk", 
     sub="Reziproke Beziehungen in rot"
     )

```

__Dyaden: Vergleich zweier Teilnetzwerke auf Reziprozität__

```{r Dyadenzensus: Vergleich zweier Netzwerke}

# Anmerkung: Das Beispiel verwendet die zuvor erstellen Teilnetzwerke h_sim und w_sim. Diese Chunks müssen zuvor aktiviert werden.

# Wir wollen herausfinden, ob die Reziprozität bei dem Hilfs- oder Zusammenarbeitsnetzwerk höher ist. Dazu müssen wir mit den zuvor erstellten Teilnetzwerken arbeiten und diese vergleichen. Hierzu passen wir die Skripte aus Kapitel 4a einfach für die beiden Teilnetzwerke an.

# A Teilnetzwerk help (Hilfestellung)

# Durchführung des Dyadenzensus
dyad_census(h_sim)

# Ausgabe der dyadischen Beziehungen nach dem MAN-Schema
# M = Mutal (reziprok)
# A = Asymmetrical (einseitig gerichtet)
# N = Null (keine Beziehung)

# Berechnung der Reziprozität
reciprocity(h_sim, mode="ratio")
# Der berechnete Wert gibt das Verhältnis von reziproken Beziehungen zu normalen Beziehungen an, in diesem Fall sind 26,08% der Beziehungen im Netzwerk reziprok.

# Genauere Analyse der reziproken Beziehungen
# Der Befehl which_mutual gibt genau an, bei welchen Knoten es sich um eine reziproke Beziehung handelt.

mh <- which_mutual(h_sim, es = E(h_sim))
mh

# Wir schreiben jetzt die Werte als Edge-Attribute in die Edgelist
E(h_sim)$reciprocity <- mh

# Wir müssen jetzt noch die Werte der Edge-Attribute in der Spalte "reciprocity" in logische Operatoren umwandeln:
E(h_sim)$reciprocity  <- as.numeric(E(h_sim)$reciprocity)

# B Teilnetzwerk work (Zusammenarbeit)

# Durchführung des Dyadenzensus
dyad_census(w_sim)

# Berechnung der Reziprozität
reciprocity(w_sim, mode="ratio")
mw <- which_mutual(w_sim, es = E(w_sim))
mw

# Wir schreiben jetzt die Werte als Edge-Attribute in die Edgelist
E(w_sim)$reciprocity <- mw
E(w_sim)$reciprocity  <- as.numeric(E(w_sim)$reciprocity)


# direkter Vergleich der Reziprozität der beiden Teilnetzwerke visualisieren
par(mfrow=c(1,2), mar=c(0,0,2,0))

plot(h_sim, 
     layout = layout_in_circle, 
     edge.arrow.size=0.4,
     vertex.color=NA,
     edge.width=E(h_sim)$weight, 
     edge.color=c("red", "NA")[(E(h_sim)$reciprocity=="0")+1],
     main="Hilfsnetzwerk (15,38% reziprok)", 
     sub="Reziproke Beziehungen in rot"
     )

plot(w_sim, 
     layout = layout_in_circle, 
     edge.arrow.size=0.4,
     vertex.color=NA,
     edge.width=E(w_sim)$weight, 
     edge.color=c("red", "NA")[(E(w_sim)$reciprocity=="0")+1],
     main="Zusammenarbeitsnetzwerk (31,57% reziprok)", 
     sub="Reziproke Beziehungen in rot"
     )

par(mfrow=c(1,1), mar=c(0,0,2,0))

# Die Analyse zeigt, dass die Beziehungen im Zusammenarbeitsnetzwerk doppelt so häufig reziprok sind, wie die Beziehungen in der Ratsuche. 

```


### Triaden

__Triadenzensus__
Der Triadenzensus ist ein etabliertes Instrument, um die Zusammensetzung von Netzwerken zu analysieren und zu vergleichen.

```{r Triadenzensus allgemein}

#  Der Zensus folgt dabei dem abgewandelten M-A-N Schema in der Beschreibung und liefert die Ergebnisse von 16 Triadentypen:

# Die Reihenfolge der Ausgabe lässt sich über den Befehl ?triad_census festlegen.
?triad_census
# Hier werden 16 Triadentypen numerisch aufsteigend abgetragen.

# Übersicht über Triaden in einem Netzwerk
triad_census(s_sim)

```

```{r Triadenstrukturen / Motifs}

# Mit dem Befehl motifs lassen sich spezifische Triadentypen anzeigen:
# Das numerische Argument legt fest, wie viele Verbindungen untersucht werden sollen.

motifs(s_sim, size=3)
count_motifs(s_sim, size=3)

# Die Anzahl der unterschiedlichen motifs entspricht grob dem Triadenzensus.
# Der Gesamtwert gibt alle triadischen Verbindungen in einem Netzwerk an.

```

In dem Netzwerk s_sim sind 383 triadische Beziehungen angelegt. Achtung: die Anzahl der Cliquen unterscheidet sich in den Teilnetzwerken!


### Cliquen
Cliquen entsprechen der Triade 300, d.h. einer komplett reziproken Struktur (A<->B<->C,A<->C).


```{r Kapitel 5c: Triadenstruktur: Cliquen}

# Zählt die Cliquen im Netzwerk
clique_num(s_sim)

# listet die Cliquen im Netzwerk auf
lc <- largest_cliques(s_sim)
lc

# Umwandlung für Visualisierung
V(s_sim)$label <- V(s_sim)$name
s_lc <- subgraph(s_sim, lc[[1]])

plot(s_lc, 
     layout=layout.fruchterman.reingold, 
     vertex.color="gold", 
     edge.arrow.size = 0.5, 
     edge.color = "gray80",
     main = "Größte Clique im CR/PR Netzwerk")
```


### Ego-Netzwerke
Manchmal ist es hilfreich, bestimmte Knoten aus dem Netzwerk zu extrahieren, um diese genauer zu untersuchen. Damit "zoomt" man auf einen Knoten im Netzwerk. Jedes Netzwerk besteht aus Egos (einzelne Knoten) und deren Alteri. Diese Ego-Netzwerke lassen sich auch einzeln analyisieren. Wir verwenden dafür die Befehle ego_size() und make_ego_graph().

Uns interessiert, wer im Netzwerk s_sim die meisten Beziehungen hat und dessen direktes Netzwerk. Deshalb selektieren wir zunächst den Knoten mit dem höchsten degree-Wert und erstellen danach das Ego-Netzwerk.

__Ego-Netzwerk __

```{r Ego-Netzwerk für den höchsten Degree erstellen}
# Achtung: beim Erstellen der Ego-Netzwerke ist es sinnvoll, das zugrundeliegende Netzwerk neu einzulesen, damit R eine saubere Indizierung vornehmen kann.

# Wir erstellen ein vereinfachtes Gesamtnetzwerk
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))

# zeigt die Knoten mit den meisten Verbindungen, ähnlich wie der degree Wert.
ego_size(s_sim)
which.max(ego_size(s_sim))

# Wir stellen fest, dass Knoten 18 die meisten degrees hat. Deshalb wollen wir ein Ego-Netzwerk aus diesem Graph generieren.
degree(s_sim)
which.max(degree(s_sim))

# selektiert aus dem Netzwerk h3 alle Knoten, die mit Knoten 18 über einen Schritt verbunden sind.
king <- make_ego_graph(s_sim, order = 1, nodes = V(s_sim)$name == 18, mode ="all")

# man braucht diesen Zwischenschrit, damit das igraph-Objekt von king1 hergestellt ist
king1 <- king[[1]]
king1

plot(king1, 
     main="Ego-Netzwerk Knoten 18, erster Grad",
     vertex.color="gold",
     vertex.frame.color=NA,
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="nur direkte Beziehungen des ersten Grads (15 alteri)")
```

__Egonetzwerk zweiter (und dritter) Ordnung__
Ego-Netzwerke lassen sich leicht um die zweite oder dritte Ordnung erweitern. Dies ermöglicht eine genauere Analyse der 

```{r Egonetzwerk zweiter Ordnung}

king2 <- make_ego_graph(s_sim, order = 2, nodes = V(s_sim)$name == 18, mode ="all")
king2 <- king2[[1]]

plot(king2, 
     main="Ego-Netzwerk Knoten 18, 2. Grad",
     vertex.color="orange",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="Beziehungen des zweiten Grads (21 alteri)")

king3 <- make_ego_graph(s_sim, order = 3, nodes = V(s_sim)$name == 18, mode ="all")
king3 <- king3[[1]]

plot(king3, 
     main="Ego-Netzwerk Knoten 18, 3. Grad",
     vertex.color="red",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="Beziehungen des dritten Grads, 22 alteri")

# erst durch die Einbezierung der Beziehungen des zweiten Grads wird die Beziehungsstruktur innerhalb des Netzwerks sichtbar. 

# Darstellung als Vergleich:

par(mfrow=c(1,3), mar=c(0,0,1,2))
plot(king1, edge.arrow.size=.3, main="Erster Grad")
plot(king2, edge.arrow.size=.3,  main="Zweiter Grad")
plot(king3, edge.arrow.size=.3, main="Dritter Grad")

par(mfrow=c(1,1), mar=c(0,0,1,2))

```

## Zentralitätsmaße
Je nach Auswahl des Netzwerks unterscheiden sich die Analyseergebnisse stark. Deshalb ist es notwendig zunächst zu klären, welche Netzwerke untersucht werden sollen. 

Damit die Daten konsistent bleiben werden hier das vereinfachte Gesamtnetzwerk sowie die vereinfachten Unternetzwerke erneut erstellt. Das ist in der Regel nicht notwendit, dient hier aber der Absicherung der Datenkonsistenz.

```{r Zentralitätsmaße: vereinfachte Netzwerke, message=FALSE, warning=FALSE, paged.print=FALSE}

# Netzwerk einlesen und vereinfachen für Analyse
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim)

# Teilnetzwerke
work <- subgraph.edges(s, E(s)[relation==1]) 
help <- subgraph.edges(s, E(s)[relation==2])
love <- subgraph.edges(s, E(s)[relation==3])

work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")

help <- delete_edge_attr(help, "relation")
help <- delete_edge_attr(help, "complicated")

love <- delete_edge_attr(love, "relation")

#Vereinfachung 
w_sim <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(w_sim)

h_sim <- simplify(help,edge.attr.comb=list(weight="sum"))
is_simple(h_sim)
```


### Degree

__Degree-Werte allgemein__
Analyse des Knotens mit den häufigsten starken Beziehungen: 

```{r Zentralität: Degree-Werte allgemein}

# 1. Knoten mit den stärksten Beziehungen im Gesamtnetzwerk
degree(s, mode="all")
which.max(degree(s, mode="all"))

# 2. Vergleich mit dem vereinfachten Netzwerk
# Vergleich mit dem einfachen simplified Netzwerk
degree(s_sim, mode="all")
which.max(degree(s_sim, mode="all"))

# 3. Teilnetzwerke 
# 3.1 Zusammenarbeit
degree(w_sim, mode="all")
which.max(degree(w_sim, mode="all"))
# 3.2 Ratsuche
degree(h_sim, mode="all")
which.max(degree(h_sim, mode="all"))

```

Der Vergleich der Netzwerke zeigt: 
- für das Gesamtnetzwerk: Knoten 18 mit einem Degree-Wert von 21
- im vereinfachten Gesamtnetzwerk: Knoten 18 mit einem Degree-Wert von 18
- Teilnetzwerk Work (vereinfacht): Knoten 19 mit einem Degree-Wert von 8
- Teilnetzwerk Help (verereinfacht): Knoten 18 mit einem Degree-Wert von 19

Die absoluten Zahlen sind allerdings nur begrenzt aussagekräftig: Deshalb lässt sich der Degree-Wert leicht normalisieren, d.h. als Prozentwert darstellen. Deshalb werden wir folgend nur noch mit den prozentualen Werten arbeiten. Diese Methode nennt sich Normalisierung und berechnet den Degree-Wert eines Knotens im Verhältnis zu allen anderen Knoten. Damit erreicht man eine genauere Aussage als mit einem reinen numerischen Wert. Dafür wird der Befehl um das Argument normalized = TRUE ergänzt.

```{r Zentralität: Degree-Werte zentralisiert}

# 1. Knoten mit den stärksten Beziehungen im Gesamtnetzwerk
degree(s, mode="all", normalized = TRUE)
which.max(degree(s, mode="all"))

# 2. Vergleich mit dem vereinfachten Netzwerk
# Vergleich mit dem einfachen simplified Netzwerk
degree(s_sim, mode="all", normalized = TRUE)
which.max(degree(s_sim, mode="all"))

# 3. Teilnetzwerke 
# 3.1 Zusammenarbeit
degree(w_sim, mode="all", normalized = TRUE)
which.max(degree(w_sim, mode="all"))
# 3.2 Ratsuche
degree(h_sim, mode="all", normalized = TRUE)
which.max(degree(h_sim, mode="all"))

```

Der Vergleich der Netzwerke zeigt: 
- für das Gesamtnetzwerk: Knoten 18 hat 56,76% aller Degree-Werte.  
- im vereinfachten Gesamtnetzwerk: Knoten 18 hat 48,46% aller Degree-Werte.
- Teilnetzwerk Work (vereinfacht): Knoten 19 hat 21,62% aller Degree-Werte.
- Teilnetzwerk Help (verereinfacht): Knoten 18 mit 40,54% aller Degree-Werte.

Mit den normalisierten, d.h. ins Verhältnis gesetzten Zahlen lassen sich viel genauere Aussagen über die positionalen Maße treffen. 

__Indegree als Popularitätsmaß__
Das Zentralitätsmaß Indegree wird häufig als Popularitätsmaß interpretiert. In diesem 

```{r Zentralität: Indegree als Popularitätsmaß}

# Gesamtnetzwerk (vereinfacht)
# zeigt die normalisierte Indegree-Verteilung im vereinfachten Gesamtnetzwerk
degree(s_sim, mode="in", normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(degree(s_sim, mode="in"))

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralität im Netzwerk der stärksten Beziehungen an
degree(w_sim, mode="in", normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(degree(w_sim, mode="in"))

# 2. Help-Netzwerk
degree(h_sim, mode="in", normalized = TRUE)
which.max(degree(h_sim, mode="in"))

# 3. Love-Netzwerk
degree(love, mode="in", normalized = TRUE)
which.max(degree(love, mode="in"))

```

__Wer ist besonders beliebt im Netzwerk?__
Das Zentralitätsmaß "indegree" liefert eine Auskunft darüber, wer in einem Netzwerk besonders populär ist. Betrachtet werden die 

_Gesamtnetzwerk_: Knoten 18 scheint im Gesamtnetzwerk mit einem Wert 35,13% der beliebteste Knoten zu sein. 

_Zusammenarbeit_: Knoten 19 ist am beliebtesten bei der Zusammenarbeit: 16,21% aller Indegrees entfallen auf diesen Knoten. 
_Unterstützung_: Knoten 18 vereint 35,13% aller Ratsuchenden auf sich. 
_Liebesbeziehung_: Knoten 23 hat den mit 22,72% ein hohes Maß an Popularität


### Betweeness und Broker im Netzwerk
Der Zentralitätswert "Betweenness" zeigt, wie relevant einzelne Knoten für die Vernetzung zu anderen Knoten sind. Es geht also um Brücken oder Broker, die zwischen den einzelnen Netzwerken verbinden können. 

```{r Zentralität: Betweenness als Broker, fig.height=10, fig.width=16, message=FALSE, warning=FALSE, paged.print=FALSE}

# Gesamtnetzwerk (vereinfacht)
# zeigt die normalisierte Indegree-Verteilung im vereinfachten Gesamtnetzwerk
betweenness(s_sim, normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(betweenness(s_sim))

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralität im Netzwerk der stärksten Beziehungen an
betweenness(w_sim, normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(betweenness(w_sim))

# 2. Help-Netzwerk
betweenness(h_sim, normalized = TRUE)
which.max(betweenness(h_sim))

# 3. Love-Netzwerk
betweenness(love, normalized = TRUE)
which.max(betweenness(love))

# weist dem Broker im vereinfachten Gesamtnetzwerk eine Farbe zu
V(s_sim)[V(s_sim)$name == 18]$vertex.color <- "red"

plot(s_sim, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     # vertex.color="gold",
     # vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Broker im Netzwerk",
     sub="vereinfachtes Hauptnetzwerk")

```

### Closeness

```{r Zentralität: Closeness, fig.height=10, fig.width=16, message=FALSE, warning=FALSE, paged.print=FALSE}
# Closeness 
??closness
# Closeness ist ein Zentralitätmaß, das berechnet, welche Knoten eng miteinander verbunden sind. Allerdings kann das Zentralitätsmaß nur bei Netzwerken eingesetzt werden, die nicht über mehrere Komponenten verfügen. Deshalb analysieren wir in diesem Beispiel nur die Hauptkomponente des vereinfachten Netzwerks und erstellen diese zunächst neu.


# Netzwerk neu einlesen und Komponenten isolieren
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
# Vereinfachtes Hauptnetzwerk
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
# Komponenten auftrennen
s_comp <- decompose.graph(s_sim)
s_comp
# Komponenten neu benennen
s_comp1 <- s_comp[[1]]
s_comp2 <- s_comp[[2]]
# neue Teilkomponenten analysieren
s_comp1
s_comp2
 
 
# Closeness
# Closness berechnet die relative Nähe zu anderen Knoten. Damit lässt sich interpretieren, welche Knoten im Netzwerk eine zentrale Rolle haben.

close <- closeness(s_comp1, mode="all", normalized=TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
close
which.max(close)
which.min(close)

# weist den größten und kleinsten Werten eine Randfarbe zu
V(s_comp1)[V(s_comp1)$name == 32]$frame.color <- "red"
V(s_comp1)[V(s_comp1)$name == 18]$frame.color <- "green"

plot(s_comp1, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     # vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Hauptkomponente",
     sub="Closeness-Werte illustriert")
     

```
In der Hauptkomponente hat Knoten 32 mit einem Wert von 35,63% die höchste Closness-Zentralität, die niedrigste hat Knoten 18 mit 13,77%.

### Spezialfall: Influencer (Bonus)
Wenn es um einflussreiche Knoten in einem Netzwerk geht, gibt es ein Spezialpaket InfluenceR, das zusätzlich installiert werden kann. Damit wird es sehr einfach, einflussreiche Knoten auszulesen. Allerdings funktioniert das Paket nur bei ungerichteten Knoten, deshalb werden wir das Netzwerk neu erstellen. 

```{r InfluencerR Paket: Analyse von einflussreichen Knoten, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}

# Installation InfluenceR Programmbibliothek (nur, falls nötig)
# install.packages("influenceR")

library(igraph)
library(influenceR)

# Einlesen des Netzwerks als ungerichtetes Netzwerk und entsprechende Vereinfachung
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=FALSE)
# Vereinfachtes Hauptnetzwerk
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
ssu <- simplify(ss,edge.attr.comb=list(weight="sum"))
# neues ungerichtetes simplifiziertes Netzwerk für InfluenceR Analyse
ssu

# Was macht die Programmbibliothek InfluenceR?
??influenceR

# Wir erhalten einige neue Funktionen hinzu:
# 1. ens(g) berechnet den Zugang zu strukturellen Löchern in einem Netzwerk
# 2. bridging(g) berechnet die Knoten, die es ermöglichen, schneller andere Knoten zu erreichen, sogenannte Brücken. (nach Valente)

holes <- ens(ssu)
which.max(holes)

bridges <- bridging(ssu)
which.max(bridges)

# weist den größten und kleinsten Werten eine Randfarbe zu
V(ssu)[V(ssu)$name == 18]$frame.color <- "green"
V(ssu)[V(ssu)$name == 5]$frame.color <- "blue"

plot(ssu, layout=layout_nicely,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     # vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Einflussreiche Knoten",
     sub="Strukturelle Löcher (grün) und Brücken (blau)")

```

Mit der Programmbibliothek InfluenceR ließen sich zwei weitere relevante Knoten isolieren, die für die Konfiguration des Netzwerks (im Falle eines ungerichteten Netzwerks) relevant sind: Knoten 18 ermöglicht es, sogenannte strukturelle Löcher im Netzwerk anzusprechen während Knoten 5 eine Brückenfunktion übernimmt. 

## Erklärungsmuster: Reziprozität, Transitivität, Homophilie

Für die Struktur von Netzwerken liegen einige Erklärungsmuster vor, dazu gehören Reziprozität, Transitivität und Homophilie.

Reziprozität ist die gegenseitige Anerkennung in Netzwerken, d.h. dass Knoten (in gerichteten Netzwerken) gegenseitig gegenseitig verbunden sind. Transitivität beschreibt die Möglichkeit, dass zwischen Knoten eine Weitergabe stattfindet während Homophilie die Ähnlichkeit von Knoten betont. 


```{r Erklärungsmuster: Netzwerk erstellen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
work <- subgraph.edges(s, E(s)[relation==1]) 
help <- subgraph.edges(s, E(s)[relation==2])

# Da es uns um Erklärungsmuster geht, werden die Nezwerke nicht vereinfacht

```

### Reziprozität
Für die Berechnung der Reziprozität im Netzwerk verwenden wir das vereinfachte Gesamtnetzwerk.

```{r Reziprozität}
??reciprocity
reciprocity(s)
reciprocity(work)
reciprocity(help)
```

Die Reziprozität im Netzwerk im Gesamtnetzwerk wird mit 43,18% berechnet. Das ist naheliegend, da das Forschungsdesign mit den Fragen der Zusammenarbeit und Ratsache per se reziproke Netzwerke bevorzugt. Als Kontrolle untersuchen wir die beiden Teilnetzwerke Ratsuche und Zusammenarbeit. Das Netzwerk der Zusammenarbeit hat die höchste ausgeprägte Reziprozität von 47,36%. Das ist naheliegend, da die Wahl der Teams häufig durch gegenseitige Sympathie bzw. vorherige Erfahrungen geprägt sind. Hingegen ist die Ratsuche deutlich einseitiger ausgeprägt mit 26,31% von reziproken Beziehungen. Auch dies erscheint aufgrund der Fragestellung naheliegend zu sein, denn die Ratsuche verläuft in den wenigsten Fällen tatsächlich reziprok (vgl. z.B. mit dem Konzept der Meinungsführer).

### Transitivität
Transitivität ist eng mit Triaden oder "Tripletts" verbunden (vgl. z.B. Hummel & Sodeur 2010). 

```{r Transitivität}
??transitivity
transitivity(s)
transitivity(work)
transitivity(help)
```
Bei der Transitivität unterscheidet sich das Bild etwas: vor allem in den Teilnetzwerken liegt eine Transitivität mit jeweils 27% bei einem Viertel der Beziehungen vor. Das bedeutet, dass hier eine triadische Struktur vorliegt, bei der Inhalte weitergegeben werden. 

### Homophilie
Die Homophilie untersucht die Strukturähnlichkeit von Knoten in Netzwerken.

```{r Homophilie}
# igraph verwendet zur Berechnung von Homophilie den Wert Assortivität: Dieser Wert gilt als positiv, wenn sich ähnliche Knoten (aufgrund deren Eigenschaften) miteinander verbinden. Ansonsten wird der Wert negativ berechnet.
??assortativity
list.vertex.attributes(s)

# Assortivität im Hauptnetzwerk
assortativity_nominal(s, V(s)$sex, directed=TRUE)
assortativity_nominal(s, V(s)$crpr, directed=TRUE)
assortativity_nominal(s, V(s)$smoke, directed=TRUE)
assortativity_nominal(s, V(s)$tatoo, directed=TRUE)

# Assortivität im Teilnetzwerk Zusammenarbeit
assortativity_nominal(work, V(work)$sex, directed=TRUE)
assortativity_nominal(work, V(work)$crpr, directed=TRUE)
assortativity_nominal(work, V(work)$smoke, directed=TRUE)
assortativity_nominal(work, V(work)$tatoo, directed=TRUE)

# Assortivität im Teilnetzwerk Zusammenarbeit
assortativity_nominal(help, V(help)$sex, directed=TRUE)
assortativity_nominal(help, V(help)$crpr, directed=TRUE)
assortativity_nominal(help, V(help)$smoke, directed=TRUE)
assortativity_nominal(help, V(help)$tatoo, directed=TRUE)
```

Die Werte im Hauptnetzwerk nach Vertex-Attributen liegen alle unter 50%, so dass hier keine Form von Homophilie festgestellt werden kann. Das gilt auch für die Teilnetzwerke Ratsuche und Zusammenarbeit. Gerade bei Zusammenarbeit wäre eine Homophilie zu vermuten gewesen. 


# Visualisiserung
Für die abschließende Visualisierung sollten Sie mindestens zwei ausgewählte Grafiken zeigen: ein Mal das Gesamtnetzwerk (ggf. mit verschiedenen Unterteilungen) und dann mindestens ein spezifisches Netzwerk, das für die Analyse besonders relevant ist. Besonders aussagekräftig werden die Analysen, wenn Netzwerke nach bestimmten Node- oder Vertex-Attributen verglichen werden oder einzelne Ego-Netzwerke analysiert werden. Achten Sie hier auch darauf, bestimmte Zentralitätmaße zu verwenden.

__Anmerkung__
Hilfreiche Visualisierungstutorials gibt es hier
[+ [Die Tutorials von K. Ognyanova](https://kateto.net/network-visualization)
[+ [Network Visualization Cookbook](https://rstudio-pubs-static.s3.amazonaws.com/341807_7b9d1a4e787146d492115f90ad75cd2d.html)
[+ [Dai Chizuka's Tutorial](https://dshizuka.github.io/networkanalysis/tutorials.html)


## Gesamtnetzwerk

```{r Visualisierung Gesamtnetzwerk , fig.height=8, fig.width=12, message=FALSE, warning=FALSE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Plotting 

# definiert die Ränder (unten, link, oben, rechts)
par(mar=c(10,1,8,1)) 

plot(s_sim,
     asp=0,
     layout=layout_nicely,
     vertex.size=degree(s_sim, mode="all"), # Knotengröße nach Degree-Wert
     vertex.label.cex=2,
     vertex.frame.color=NA,
     edge.arrow.size=.7,
     edge.color="black",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu ermöglichen
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     )

title("Gesamtnetzwerk vereinfacht", 
      sub = "aggregierte Gewichte von Ratsuche und Zusammenarbeit",
      cex.main = 3, col.main= "orange",
      cex.sub = 2, font.sub = 3, col.sub = "black")

par(mar=c(2,2,2,2)) 

```
```{r Visualisierung von Farbverläufen von Werten, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}

library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Berechnung des Indegree-Werts normalisiert
ins <- degree(s, mode = "in", normalized = TRUE)

# legt die Farbskala fest
palette = colorRampPalette(c('lightblue','darkblue'))

# die Palette wird in 10 Schritte unterteilt.
fine = 10
graphCol = palette(fine)[as.numeric(cut(ins, breaks = fine))] 

# der folgende Plot ist um einige weitere Visualisierungsparameter ergänzt

par(mar=c(10,1,10,1))

plot(s, 
     asp=0,
     rescale=TRUE,
     layout=layout_nicely,
     vertex.color=graphCol, #verwende als Farbe die Farbpalette 
     vertex.label=NA,
     vertex.size=6, # hier könnte auch die Größe der indegrees gesetzt werden
     vertex.frame.color = "white", 
     edge.color="lightblue", 
     edge.width=E(s_sim)$weight/2, 
     edge.curved=.2,
     edge.curved=curve_multiple(s)
)

title("Wer wird um Rat gefragt? (n=38)", 
      sub = "Visualisierung nach normalisierter Indegree-Verteilung",
      cex.main = 2, col.main= "darkblue",
      cex.sub = 2, font.sub = 3, col.sub = "black")

```




### Gesamtnetzwerk nach Node-Attribut: Vertiefung und Geschlecht

```{r Geschlechtsverteilung, fig.height=8, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}

library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Farben und Formen setzen

# weist den Attributswerten entsprechende Farben zu
V(s)[V(s)$sex == 1]$color <- "pink"
V(s)[V(s)$sex == 2]$color <- "lightblue"
V(s)[V(s)$sex == 3]$color <- "lightgreen"

# weist den Attributswerten der Vertiefung entsprechende Formen zu
vertex.attributes(s)$crpr
V(s)[V(s)$crpr == 1]$shape <- "square"  
V(s)[V(s)$crpr == 2]$shape <- "circle"


# definiert die Ränder (unten, link, oben, rechts)
par(mar=c(12,1,8,1)) 

plot(s,
     asp=0,
     layout=layout_nicely,
     # vertex.size=degree(s, mode="all"), # Knotengröße nach Degree-Wert
     vertex.frame.color=NA,
     vertex.size=7,
     vertex.label.cex=1,
     vertex.label.color="black",
     edge.arrow.size=.7,
     edge.color="gray20",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu ermöglichen
     edge.curved=.2,
     edge.curved=curve_multiple(s),
     )

title("Gesamtnetzwerk: Vertiefung und Geschlecht", 
      sub = "Vertiefung und Geschlecht",
      cex.main = 2, col.main= "black",
      cex.sub = 2, font.sub = 3, col.sub = "black")

par(mar=c(2,2,2,2)) 
```

### Multiplexes Netzwerk
Um das etwas übersichtlicher darszustellen, bietet sich bei einem Netzwerk mit verschiedenen Beziehungsarten an, diese farblich zu unterscheiden. 

```{r Visualisierung eines multiplexe Netzwerke erstellen, fig.height=8, fig.width=10}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# definiert die Farbe der Relation
E(s)[E(s)$relation == 1]$color <- "blue" 
E(s)[E(s)$relation == 2]$color <- "darkgreen"
E(s)[E(s)$relation == 3]$color <- "red"

# Plot mit den gesetzten Farben für das Attribut Beziehung realisieren

# Visualisierungsparameter festlegen
par(mar=c(6,3,3,3)) 

# Plot mit den gesetzten Farben für das Attribut Beziehung realisieren
plot(s,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, d.h. verschiedene Formen der Beziehung",
     sub="n=38 Knoten; Kantenfarbe 
     blau=Zusammenarbeit, grün=Ratsuche, rot=Beziehung")

par(mar=c(0,0,0,0)) 
# setzt die Seitenaufteilung zurück
par(mfrow=c(1,1), mar=c(2,0,2,0)) 

```

```{r Teilnetzwerke im Vergleich, fig.height=6, fig.width=9, message=FALSE, warning=FALSE, paged.print=FALSE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# definiert die Farbe der Relation
E(s)[E(s)$relation == 1]$color <- "blue" 
E(s)[E(s)$relation == 2]$color <- "darkgreen"
E(s)[E(s)$relation == 3]$color <- "red"

# erstellt die Teilnetzwerke 
work <- subgraph.edges(s, E(s)[relation==1]) 
help <- subgraph.edges(s, E(s)[relation==2])
love <- subgraph.edges(s, E(s)[relation==3])

# Drei Netzwerke in einer Ziele
par(mfrow=c(1,3), mar=c(2,0,2,0)) 

# Drei Teilnetzwerke nacheinander plotten, diese werden dann in einer Zeile dargestellt

plot(work,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(work),
     main="Teilnetzwerk Work",
     sub="n=38 Knoten; Kantenfarbe blau"
     )

plot(help,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(help),
     main="Teilnetzwerk Help",
     sub="n=38 Knoten; Kantenfarbe grün",
)
     
plot(love,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(love),
     main="Teilnetzwerk Help",
     sub="n=38 Knoten; Kantenfarbe grün"
)

# setzt die Seitenaufteilung zurück
par(mfrow=c(1,1), mar=c(2,0,2,0)) 

```



# Diskussion: Fazit, Limitationen und Ausblick
Hier findet die Diskussion der Ergebnisse statt:
- Wurden anfangs Arbeitshypothesen aufgestellt? Lassen sich diese bestätigen oder widerlegen?
- Welche (neuen) Erkenntnisse hat die Analyse gebracht?
- Wo liegen die Limitationen in der Studie?
- Was könnten nächste Schritte in der Forschung sein?

# Anlage
## Literatur

Dunkake I. (2012). Soziale Netzwerke von Schülern: Beispiele angewandter Netzwerkanalysen. In: Hennig M. & Stegbauer C. (Hg.): Die Integration von Theorie und Methode in der Netzwerkforschung. Wiesbaden: VS Verlag für Sozialwissenschaften, S. 133-155.

Hummel & Sodeur (2010). Dyaden und Triaden. In: Stegbauer, C. & Häußling, R. (Hg.): Handbuch Netzwerkforschung. Wiesbaden: VS Verlag, S.  

Krackhardt D. (1987). Cognitive social structures. Social Networks, 9, 104-134.  

Luke, D. A. (2015). A user's guide to network analysis in R. Cham, Switzerland: Springer.  

Ognyanova, K.(2019). Network Visualization with R. Sunbelt 2019 Workshop, Montreal, Canada. www.kateto.net/sunbelt2019   

## Codebuch
[Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md)

```{r Übersicht Netzwerkattribute}
list.vertex.attributes(s)
# vertex.attributes(s)
list.edge.attributes(s)
# edge.attributes(s)
```

Das Netzwerk hat nach dem [Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md) folgende Attribute:

*Vertex-Attribute*
- name: Name des Knotens, anonym codiert von 1 bis 38
- sex: Geschlecht 1 weiblich, 2 männlich, 3 divers
- crpr: Vertiefungsrichtung (1 CR, 2 PR)
- age: Alter 1 bis 20, 2 21-22, 3 23-24, 4 25 und älter
- smoke: Nichtraucher 1, Raucher 2
- tatoo: nein 1, ja 2
- eyes: Augenfarbe: 1 grün, 2 blau, 3 braun, 4 blau.
- hair: Haarfarbe: 1 braun, 2 schwarz, 3 blond, 4 rot

Die Vertex-Attribute treffen auf alle Knoten zu.

*Edge-Attribute*
- weight: Erste Nennung (Primärer Kontakt). Zweite Nennung (Sekunderärer Kontakt)
- relation: Ratsuche (help), Zusammenarbeit (work), Liebesbeziehung (love)
- complicated: bezieht sich nur auf das Teilnetzwerk Liebesbeziehung

Die Edge-Attribute sind unterschiedlich verteilt. Durch die Erhebung haben die Studierenden ein Ratsuchenetzwerk (Wen fragst Du um Rat?) und ein Zusammenarbeitsnetzwerk (Mit wem arbeitest Du am liebsten zusammen?) angeben müssen. Für beide Fragen gab es eine erste und ein zweite Nennung. Die erste Nennung wird entsprechend höher gewichtet. Die Fragen waren verpflichtend. Das bedeutet, dass die Edges sich wie folgt verteilen: 38*2 = 76 Beziehungenangaben für jeweils help und work.


## Datenmaterial und Skript
[Datensatz](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/readme.md)

## Team, Arbeitsaufwand und Lessons Learned

### Teammitglieder
NN
NN
NN

### Arbeitsaufwand und Rollen im Team
NN: Projektleitung und Coding, ca. 80 Stunden
NN: Literaturrecherche und Auswertung, ca. 80 Stunden
NN: Endbericht und Visualiserung, ca. 80 Stunden


### Lessons learned
Bitte beschreiben Sie kurz als Team, was ihre größte Herausforderung war und was der größte Lernerfolg in dem Projekt. 
